{"version":3,"sources":["webpack:///page-component---src-pages-unity-3-d-pick-and-drag-js-f2761a7eea84bf83e88e.js","webpack:///./src/img/companion_cube.png","webpack:///./src/pages/unity3d-pick-and-drag.js"],"names":["webpackJsonp","./src/img/companion_cube.png","module","exports","__webpack_require__","p","./node_modules/babel-loader/lib/index.js?{\"plugins\":[\"D:/dev/website-src/node_modules/gatsby/dist/utils/babel-plugin-extract-graphql.js\",\"D:/dev/website-src/node_modules/babel-plugin-add-module-exports/lib/index.js\",\"D:/dev/website-src/node_modules/babel-plugin-add-module-exports/lib/index.js\",\"D:/dev/website-src/node_modules/babel-plugin-transform-object-assign/lib/index.js\"],\"presets\":[\"D:/dev/website-src/node_modules/babel-preset-env/lib/index.js\",\"D:/dev/website-src/node_modules/babel-preset-stage-0/lib/index.js\",\"D:/dev/website-src/node_modules/babel-preset-react/lib/index.js\"],\"cacheDirectory\":true}!./src/pages/unity3d-pick-and-drag.js","_interopRequireDefault","obj","__esModule","default","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","call","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","defineProperty","title","date","undefined","_createClass","defineProperties","target","props","i","length","descriptor","key","protoProps","staticProps","_react","_react2","_code","_code2","_comments","_comments2","_pageTitle","_pageTitle2","_sectionTitle","_sectionTitle2","_paragraph","_paragraph2","_inlineCode","_inlineCode2","_articleImages","_articleImages2","_video","_video2","_companion_cube","_companion_cube2","Page","_React$Component","this","getPrototypeOf","apply","arguments","createElement","text","images","src","lang","Component"],"mappings":"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","file":"page-component---src-pages-unity-3-d-pick-and-drag-js-f2761a7eea84bf83e88e.js","sourcesContent":["webpackJsonp([1570422109460401700],{\n\n/***/ \"./src/img/companion_cube.png\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"static/companion_cube.9be1b5d8.png\";\n\n/***/ }),\n\n/***/ \"./node_modules/babel-loader/lib/index.js?{\\\"plugins\\\":[\\\"D:/dev/website-src/node_modules/gatsby/dist/utils/babel-plugin-extract-graphql.js\\\",\\\"D:/dev/website-src/node_modules/babel-plugin-add-module-exports/lib/index.js\\\",\\\"D:/dev/website-src/node_modules/babel-plugin-add-module-exports/lib/index.js\\\",\\\"D:/dev/website-src/node_modules/babel-plugin-transform-object-assign/lib/index.js\\\"],\\\"presets\\\":[\\\"D:/dev/website-src/node_modules/babel-preset-env/lib/index.js\\\",\\\"D:/dev/website-src/node_modules/babel-preset-stage-0/lib/index.js\\\",\\\"D:/dev/website-src/node_modules/babel-preset-react/lib/index.js\\\"],\\\"cacheDirectory\\\":true}!./src/pages/unity3d-pick-and-drag.js\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.title = exports.date = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _react = __webpack_require__(\"./node_modules/react/react.js\");\n\t\n\tvar _react2 = _interopRequireDefault(_react);\n\t\n\tvar _code = __webpack_require__(\"./src/shared/code.js\");\n\t\n\tvar _code2 = _interopRequireDefault(_code);\n\t\n\tvar _comments = __webpack_require__(\"./src/shared/comments.js\");\n\t\n\tvar _comments2 = _interopRequireDefault(_comments);\n\t\n\tvar _pageTitle = __webpack_require__(\"./src/shared/page-title.js\");\n\t\n\tvar _pageTitle2 = _interopRequireDefault(_pageTitle);\n\t\n\tvar _sectionTitle = __webpack_require__(\"./src/shared/section-title.js\");\n\t\n\tvar _sectionTitle2 = _interopRequireDefault(_sectionTitle);\n\t\n\tvar _paragraph = __webpack_require__(\"./src/shared/paragraph.js\");\n\t\n\tvar _paragraph2 = _interopRequireDefault(_paragraph);\n\t\n\tvar _inlineCode = __webpack_require__(\"./src/shared/inline-code.js\");\n\t\n\tvar _inlineCode2 = _interopRequireDefault(_inlineCode);\n\t\n\tvar _articleImages = __webpack_require__(\"./src/shared/article-images.js\");\n\t\n\tvar _articleImages2 = _interopRequireDefault(_articleImages);\n\t\n\tvar _video = __webpack_require__(\"./src/shared/video.js\");\n\t\n\tvar _video2 = _interopRequireDefault(_video);\n\t\n\tvar _companion_cube = __webpack_require__(\"./src/img/companion_cube.png\");\n\t\n\tvar _companion_cube2 = _interopRequireDefault(_companion_cube);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar date = exports.date = '07 Sep 2014';\n\tvar title = exports.title = 'Unity3d tip: implementing pick-and-drag mechanics in a first-person game';\n\t\n\tvar Page = function (_React$Component) {\n\t    _inherits(Page, _React$Component);\n\t\n\t    function Page() {\n\t        _classCallCheck(this, Page);\n\t\n\t        return _possibleConstructorReturn(this, (Page.__proto__ || Object.getPrototypeOf(Page)).apply(this, arguments));\n\t    }\n\t\n\t    _createClass(Page, [{\n\t        key: 'render',\n\t        value: function render() {\n\t            return _react2.default.createElement(\n\t                'div',\n\t                null,\n\t                _react2.default.createElement(_pageTitle2.default, { text: title, date: date }),\n\t                _react2.default.createElement(_articleImages2.default, { images: [_companion_cube2.default] }),\n\t                _react2.default.createElement(\n\t                    _paragraph2.default,\n\t                    null,\n\t                    'Picking and dragging objects around is something that you can see quite often in various games with the first-person camera view. This features adds a lot to the level of interactivity with the game environment, so developers build their game mechanics around this feature for a good reason.'\n\t                ),\n\t                _react2.default.createElement(\n\t                    _paragraph2.default,\n\t                    null,\n\t                    'So, how to implement this inside Unity? I\\u2019ve seen some implementations ranging from the very simple to the more advanced ones. In this post I\\u2019ll try to explain what I don\\u2019t like about some of them and propose my own solution with an interesting hack behind it.'\n\t                ),\n\t                _react2.default.createElement(\n\t                    _paragraph2.default,\n\t                    null,\n\t                    'Lets assume that we have a camera object in the scene. It doesn\\u2019t matter how the camera is controlled, in my case it is attached to the player object. Let\\u2019s say we want, while looking through this camera, to pick objects, hold them in front of the camera, carry them around while the camera is moving, then put them to the ground or throw away. Assume picked objects to be rigid bodies. Here and throughout the rest of this article I will refer to the point to which objects are attached to while moving as the pivot point.'\n\t                ),\n\t                _react2.default.createElement(\n\t                    _paragraph2.default,\n\t                    null,\n\t                    _react2.default.createElement(\n\t                        'strong',\n\t                        null,\n\t                        'Solution 1:'\n\t                    ),\n\t                    ' calculate pivot point offset each frame and move the picked object by that offset.',\n\t                    _react2.default.createElement('br', null),\n\t                    'Pros:',\n\t                    _react2.default.createElement(\n\t                        'ul',\n\t                        null,\n\t                        _react2.default.createElement(\n\t                            'li',\n\t                            null,\n\t                            'Easy to implement.'\n\t                        )\n\t                    ),\n\t                    'Cons:',\n\t                    _react2.default.createElement(\n\t                        'ul',\n\t                        null,\n\t                        _react2.default.createElement(\n\t                            'li',\n\t                            null,\n\t                            'Direct manipulation with the rigid body position may lead to the physics simulation instability and artifacts. It\\u2019s always a good rule to move (non-kinematic) rigid bodies by applying forces.'\n\t                        )\n\t                    )\n\t                ),\n\t                _react2.default.createElement(\n\t                    _paragraph2.default,\n\t                    null,\n\t                    _react2.default.createElement(\n\t                        'strong',\n\t                        null,\n\t                        'Solution 2:'\n\t                    ),\n\t                    ' make object a child of the camera.',\n\t                    _react2.default.createElement('br', null),\n\t                    'Pros:',\n\t                    _react2.default.createElement(\n\t                        'ul',\n\t                        null,\n\t                        _react2.default.createElement(\n\t                            'li',\n\t                            null,\n\t                            'Easy to implement.'\n\t                        )\n\t                    ),\n\t                    'Cons:',\n\t                    _react2.default.createElement(\n\t                        'ul',\n\t                        null,\n\t                        _react2.default.createElement(\n\t                            'li',\n\t                            null,\n\t                            'Same as for solution 1. (Non-kinematic) Rigid bodies should only be controlled by forces and not by direct position manipulations, which is what parent-child relationship actually does.'\n\t                        )\n\t                    )\n\t                ),\n\t                _react2.default.createElement(\n\t                    _paragraph2.default,\n\t                    null,\n\t                    _react2.default.createElement(\n\t                        'strong',\n\t                        null,\n\t                        'Solution 3:'\n\t                    ),\n\t                    ' use joints. Construct a joint and attach one end of it to the rigid body, and the other end to the pivot point.',\n\t                    _react2.default.createElement('br', null),\n\t                    'Pros:',\n\t                    _react2.default.createElement(\n\t                        'ul',\n\t                        null,\n\t                        _react2.default.createElement(\n\t                            'li',\n\t                            null,\n\t                            '\\u201CPhysically correct\\u201D way to control the rigid body. The body follows the pivot point and is able to react to collisions.'\n\t                        )\n\t                    ),\n\t                    'Cons:',\n\t                    _react2.default.createElement(\n\t                        'ul',\n\t                        null,\n\t                        _react2.default.createElement(\n\t                            'li',\n\t                            null,\n\t                            'Object reaction to camera movements is laggy and twitching (lag amount depends on the joint type).'\n\t                        ),\n\t                        _react2.default.createElement(\n\t                            'li',\n\t                            null,\n\t                            'Object starts to jump around the pivot point when camera makes sudden movements (true for spring joints, can be fixed by setting a high dumping value).'\n\t                        ),\n\t                        _react2.default.createElement(\n\t                            'li',\n\t                            null,\n\t                            'Difficult to adjust the joint parameters to achieve somewhat of a believable result.'\n\t                        )\n\t                    )\n\t                ),\n\t                _react2.default.createElement(\n\t                    _paragraph2.default,\n\t                    null,\n\t                    'The solution utilising joints is the most complex of the three, but after a good tuning it produces believable results. Its main flaw for me, however, was the twitching object movement. When you drag a body that is attached to the pivot point with a fixed joint, the body is supposed to strictly preserve its position relative to the pivot point. The thing is that physical joints have \\u201Cspringy\\u201D nature (even if they are not spring joints), so the body will always behave a bit strange at high movement rates, twitching and slightly moving around the pivot point. What I want is to have the picked object be directly at the same spot all the time when it is dragged.'\n\t                ),\n\t                _react2.default.createElement(_sectionTitle2.default, { text: 'Solution' }),\n\t                _react2.default.createElement(\n\t                    _paragraph2.default,\n\t                    null,\n\t                    'My solution doesn\\u2019t rely on joints. Instead, it moves the body by changing its velocity, which is also an acceptable way of moving rigid bodies. It also implements a hack that allows you to completely eliminate the body movement relative to the pivot point. You can see the final result in this video:'\n\t                ),\n\t                _react2.default.createElement(_video2.default, { src: '//www.youtube.com/embed/zM_o6zB9B5s' }),\n\t                _react2.default.createElement(\n\t                    _paragraph2.default,\n\t                    null,\n\t                    'The hack is to drag ',\n\t                    _react2.default.createElement(\n\t                        'i',\n\t                        null,\n\t                        'two'\n\t                    ),\n\t                    ' objects instead of one. The first object is the visual representation (avatar) of the initial body. It has no RigidBody component and is moved by directly manipulating its position. The second object is not visible at all and represents the physical aspect of the body, having a RigidBody component attached to it. Fast camera movements might somehow make it behave oddly, but the player doesn\\u2019t see it anyway. There\\u2019s no need to perform complex tweaking of the joint to make results look good (which is extremely hard from what I\\u2019ve experienced). The only tricky part is when the physical avatar collides with other objects in the scene. When this occurs, we just align the visual avatar with the physical one so that both of them react to collisions. When nothing happens, the visual avatar moves with the camera.'\n\t                ),\n\t                _react2.default.createElement(\n\t                    _paragraph2.default,\n\t                    null,\n\t                    'Below is the code with some explaining comments:'\n\t                ),\n\t                _react2.default.createElement(\n\t                    _code2.default,\n\t                    { lang: 'csharp' },\n\t                    'public class HeldObject : MonoBehaviour\\n{\\n    public bool IsColliding { get; private set; }\\n\\n    private void OnCollisionEnter(Collision collision)\\n    {\\n        IsColliding = true;\\n    }\\n\\n    private void OnTriggerStay(Collider other)\\n    {\\n        IsColliding = true;\\n    }\\n\\n    private void OnCollisionExit(Collision collision)\\n    {\\n        IsColliding = false;\\n    }\\n}\\n\\n\\npublic class PlayerPick : MonoBehaviour\\n{\\n    // Maximum distance from the camera at which the object can be picked up\\n    public float MaxPickDistance;\\n    public float ThrowStrength = 10;\\n    public float HeldObjectFollowStrength = 50;\\n\\n    private Player _player;\\n    private Camera _playerCam;\\n    private GameObject _pivot;\\n\\n    private HeldObject _heldObject; // physical avatar\\n    private GameObject _heldBodyAvatar; // visual avatar\\n    private float _heldBodyAngularDrag;\\n\\n    private RaycastHit? _raycast;\\n\\n    private void Start()\\n    {\\n        _player = Player.Instance;\\n        _playerCam = Player.Camera;\\n        _pivot = Player.PickPivot;\\n    }\\n\\n    private void Update()\\n    {\\n        Raycast();\\n        if (Input.GetKeyDown(KeyCode.E))\\n        {\\n            if (!_heldObject)\\n                TakeObject();\\n            else\\n                ReleaseObject();\\n        }\\n        HoldObject();\\n        if (Input.GetMouseButton(0) && _heldObject)\\n            ThrowObject();\\n    }\\n\\n    private void Raycast()\\n    {\\n        _raycast = null;\\n        const int layerMask = 1 << 8;\\n        var raycastHits = Physics.RaycastAll(_playerCam.transform.position, _playerCam.transform.forward,\\n                                             MaxPickDistance, ~layerMask);\\n        foreach (var hit in raycastHits)\\n        {\\n            if (hit.collider == _player.collider || !hit.collider.rigidbody) // avoid colliding with the player object itself\\n                continue;\\n            _raycast = hit;\\n        }\\n    }\\n\\n    private void HoldObject()\\n    {\\n        if (!_heldObject)\\n            return;\\n        // Drag the physical avatar by changing its velocity\\n        _heldObject.rigidbody.velocity = HeldObjectFollowStrength * (_pivot.transform.position - _heldObject.transform.position);\\n        // When the physical avatar collides, we move the visual one to the same position. When this doesn\\'t happen,\\n        // move the visuals back to the pivot point.\\n        _heldBodyAvatar.transform.position = _heldObject.IsColliding\\n            ? _heldObject.transform.position\\n            : _pivot.transform.position;\\n        // If the physical avatar is colliding with something, change visuals rotation to correspond\\n        if (_heldObject.IsColliding)\\n            _heldBodyAvatar.transform.rotation = _heldObject.transform.rotation;\\n    }\\n\\n    private void TakeObject()\\n    {\\n        if (!_raycast.HasValue)\\n            return;\\n\\n        var heldBody = _raycast.Value.rigidbody;\\n        heldBody.transform.position = _pivot.transform.position;\\n        heldBody.useGravity = false;\\n\\n        _heldBodyAngularDrag = heldBody.angularDrag;\\n        heldBody.angularDrag = 1; // so that the object doesn\\'t continue rotating after each collision\\n        heldBody.renderer.enabled = false;\\n        _heldObject = heldBody.gameObject.AddComponent<HeldObject>();\\n\\n        _heldBodyAvatar = new GameObject(\"Held body avatar\");\\n        _heldBodyAvatar.transform.parent = _playerCam.transform;\\n        _heldBodyAvatar.transform.position = _pivot.transform.position;\\n        _heldBodyAvatar.transform.rotation = heldBody.transform.rotation;\\n        _heldBodyAvatar.transform.localScale = heldBody.transform.localScale;\\n        _heldBodyAvatar.AddComponent<MeshFilter>().sharedMesh = heldBody.gameObject.GetComponent<MeshFilter>().sharedMesh;\\n        _heldBodyAvatar.AddComponent<MeshRenderer>().sharedMaterial = heldBody.gameObject.renderer.sharedMaterial;\\n\\n        Physics.IgnoreCollision(heldBody.collider, Player.Controller, true);\\n    }\\n\\n    private void ReleaseObject(Action onRelease = null)\\n    {\\n        Physics.IgnoreCollision(_heldObject.collider, Player.Controller, false);\\n        _heldObject.rigidbody.useGravity = true;\\n        _heldObject.rigidbody.angularDrag = _heldBodyAngularDrag;\\n        _heldObject.rigidbody.transform.position = _heldBodyAvatar.transform.position;\\n        _heldObject.rigidbody.transform.rotation = _heldBodyAvatar.transform.rotation;\\n        _heldObject.rigidbody.renderer.enabled = true;\\n        _heldBodyAvatar.renderer.enabled = false;\\n        Destroy(_heldObject);\\n        Destroy(_heldBodyAvatar);\\n        if (onRelease != null)\\n            onRelease();\\n        _heldObject = null;\\n    }\\n\\n    private void ThrowObject()\\n    {\\n        ReleaseObject(() => _heldObject.rigidbody.AddForce(_playerCam.transform.forward * ThrowStrength, ForceMode.Impulse));\\n    }\\n}'\n\t                ),\n\t                _react2.default.createElement(\n\t                    _paragraph2.default,\n\t                    null,\n\t                    'This algorithm could probably be improved by, for example, simplifying the ',\n\t                    _react2.default.createElement(\n\t                        _inlineCode2.default,\n\t                        null,\n\t                        'TakeObject'\n\t                    ),\n\t                    ' method. If the body that has been picked has complex visuals and a lot of components on it, it might be easier not to copy everything into a new visual avatar. Instead, you can leave the visuals on the object, and just create a new physical avatar. In my case the object itself remains physical, and all visuals go to the new object.'\n\t                ),\n\t                _react2.default.createElement(_comments2.default, null)\n\t            );\n\t        }\n\t    }]);\n\t\n\t    return Page;\n\t}(_react2.default.Component);\n\t\n\texports.default = Page;\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// page-component---src-pages-unity-3-d-pick-and-drag-js-f2761a7eea84bf83e88e.js","module.exports = __webpack_public_path__ + \"static/companion_cube.9be1b5d8.png\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/img/companion_cube.png\n// module id = ./src/img/companion_cube.png\n// module chunks = 1570422109460401700 4016850265702045000","import React from 'react';\r\nimport Code from './../shared/code';\r\nimport Comments from './../shared/comments';\r\nimport PageTitle from './../shared/page-title';\r\nimport SectionTitle from './../shared/section-title';\r\nimport Paragraph from './../shared/paragraph';\r\nimport InlineCode from './../shared/inline-code';\r\nimport ArticleImages from './../shared/article-images';\r\nimport Video from './../shared/video';\r\n\r\nimport img1 from './../img/companion_cube.png';\r\n\r\nexport const date = '07 Sep 2014';\r\nexport const title = 'Unity3d tip: implementing pick-and-drag mechanics in a first-person game';\r\n\r\nexport default class Page extends React.Component {\r\n    render() {\r\n        return (\r\n            <div>\r\n                <PageTitle text={title} date={date}/>\r\n\r\n                <ArticleImages images={[img1]}/>\r\n\r\n                <Paragraph>\r\n                    Picking and dragging objects around is something that you can see quite often in\r\n                    various games with the first-person camera view. This features adds a lot to\r\n                    the level of interactivity with the game environment, so developers build\r\n                    their game mechanics around this feature for a good reason.\r\n                </Paragraph>\r\n\r\n                <Paragraph>\r\n                    So, how to implement this inside Unity? I’ve seen some\r\n                    implementations ranging from the very simple to the more\r\n                    advanced ones. In this post I’ll try to explain what I don’t like\r\n                    about some of them and propose my own solution with an interesting hack behind it.\r\n                </Paragraph>\r\n\r\n                <Paragraph>\r\n                    Lets assume that we have a camera object in the scene.\r\n                    It doesn’t matter how the camera is controlled, in my case\r\n                    it is attached to the player object. Let’s say we want, while\r\n                    looking through this camera, to pick objects, hold them in front\r\n                    of the camera, carry them around while the camera is moving,\r\n                    then put them to the ground or throw away. Assume picked objects\r\n                    to be rigid bodies. Here and throughout the rest of this article\r\n                    I will refer to the point to which objects are attached to while\r\n                    moving as the pivot point.\r\n                </Paragraph>\r\n\r\n                <Paragraph>\r\n                    <strong>Solution 1:</strong> calculate pivot point offset each\r\n                    frame and move the picked object by that offset.<br/>\r\n                    Pros:\r\n                    <ul>\r\n                        <li>Easy to implement.</li>\r\n                    </ul>\r\n\r\n                    Cons:\r\n                    <ul>\r\n                        <li>\r\n                            Direct manipulation with the rigid body position may lead to the physics\r\n                            simulation instability and artifacts. It’s always a good rule\r\n                            to move (non-kinematic) rigid bodies by applying forces.\r\n                        </li>\r\n                    </ul>\r\n                </Paragraph>\r\n\r\n                <Paragraph>\r\n                    <strong>Solution 2:</strong> make object a child of the camera.<br/>\r\n                    Pros:\r\n                    <ul>\r\n                        <li>Easy to implement.</li>\r\n                    </ul>\r\n                    Cons:\r\n                    <ul>\r\n                        <li>Same as for solution 1. (Non-kinematic) Rigid bodies should only be\r\n                        controlled by forces and not by direct position manipulations,\r\n                        which is what parent-child relationship actually does.\r\n                        </li>\r\n                    </ul>\r\n                </Paragraph>\r\n\r\n                <Paragraph>\r\n                    <strong>Solution 3:</strong> use joints. Construct a joint and attach one\r\n                    end of it to the rigid body, and the other end to the pivot point.<br/>\r\n                    Pros:\r\n                    <ul>\r\n                        <li>“Physically correct” way to control the rigid body. The body\r\n                        follows the pivot point and is able to react to collisions.\r\n                        </li>\r\n                    </ul>\r\n\r\n                    Cons:\r\n                    <ul>\r\n                        <li>\r\n                            Object reaction to camera movements is laggy and twitching\r\n                            (lag amount depends on the joint type).\r\n                        </li>\r\n                        <li>\r\n                            Object starts to jump around the pivot point when camera makes sudden\r\n                            movements (true for spring joints, can be fixed by setting a high dumping value).\r\n                        </li>\r\n                        <li>\r\n                            Difficult to adjust the joint parameters to achieve somewhat of a believable result.\r\n                        </li>\r\n                    </ul>\r\n                </Paragraph>\r\n\r\n                <Paragraph>\r\n                    The solution utilising joints is the most complex of the three,\r\n                    but after a good tuning it produces believable results. Its main\r\n                    flaw for me, however, was the twitching object movement. When you\r\n                    drag a body that is attached to the pivot point with a fixed joint,\r\n                    the body is supposed to strictly preserve its position relative to\r\n                    the pivot point. The thing is that physical joints have “springy” nature\r\n                    (even if they are not spring joints), so the body will always behave\r\n                    a bit strange at high movement rates, twitching and slightly moving\r\n                    around the pivot point. What I want is to have the picked object be\r\n                    directly at the same spot all the time when it is dragged.\r\n                </Paragraph>\r\n\r\n                <SectionTitle text=\"Solution\" />\r\n\r\n                <Paragraph>\r\n                    My solution doesn’t rely on joints. Instead, it moves the body by changing\r\n                    its velocity, which is also an acceptable way of moving rigid bodies.\r\n                    It also implements a hack that allows you to completely eliminate the\r\n                    body movement relative to the pivot point. You can see the final result in this video:\r\n                </Paragraph>\r\n\r\n                <Video src=\"//www.youtube.com/embed/zM_o6zB9B5s\" />\r\n\r\n                <Paragraph>\r\n                    The hack is to drag <i>two</i> objects instead of one. The first object is the visual\r\n                    representation (avatar) of the initial body. It has no RigidBody component and\r\n                    is moved by directly manipulating its position. The second object is not visible\r\n                    at all and represents the physical aspect of the body, having a RigidBody component\r\n                    attached to it. Fast camera movements might somehow make it behave oddly, but\r\n                    the player doesn’t see it anyway. There’s no need to perform complex tweaking\r\n                    of the joint to make results look good (which is extremely hard from what I’ve\r\n                    experienced). The only tricky part is when the physical avatar collides with\r\n                    other objects in the scene. When this occurs, we just align the visual avatar\r\n                    with the physical one so that both of them react to collisions. When nothing\r\n                    happens, the visual avatar moves with the camera.\r\n                </Paragraph>\r\n\r\n                <Paragraph>\r\n                    Below is the code with some explaining comments:\r\n                </Paragraph>\r\n\r\n                <Code lang=\"csharp\">\r\n{`public class HeldObject : MonoBehaviour\r\n{\r\n    public bool IsColliding { get; private set; }\r\n\r\n    private void OnCollisionEnter(Collision collision)\r\n    {\r\n        IsColliding = true;\r\n    }\r\n\r\n    private void OnTriggerStay(Collider other)\r\n    {\r\n        IsColliding = true;\r\n    }\r\n\r\n    private void OnCollisionExit(Collision collision)\r\n    {\r\n        IsColliding = false;\r\n    }\r\n}\r\n\r\n\r\npublic class PlayerPick : MonoBehaviour\r\n{\r\n    // Maximum distance from the camera at which the object can be picked up\r\n    public float MaxPickDistance;\r\n    public float ThrowStrength = 10;\r\n    public float HeldObjectFollowStrength = 50;\r\n\r\n    private Player _player;\r\n    private Camera _playerCam;\r\n    private GameObject _pivot;\r\n\r\n    private HeldObject _heldObject; // physical avatar\r\n    private GameObject _heldBodyAvatar; // visual avatar\r\n    private float _heldBodyAngularDrag;\r\n\r\n    private RaycastHit? _raycast;\r\n\r\n    private void Start()\r\n    {\r\n        _player = Player.Instance;\r\n        _playerCam = Player.Camera;\r\n        _pivot = Player.PickPivot;\r\n    }\r\n\r\n    private void Update()\r\n    {\r\n        Raycast();\r\n        if (Input.GetKeyDown(KeyCode.E))\r\n        {\r\n            if (!_heldObject)\r\n                TakeObject();\r\n            else\r\n                ReleaseObject();\r\n        }\r\n        HoldObject();\r\n        if (Input.GetMouseButton(0) && _heldObject)\r\n            ThrowObject();\r\n    }\r\n\r\n    private void Raycast()\r\n    {\r\n        _raycast = null;\r\n        const int layerMask = 1 << 8;\r\n        var raycastHits = Physics.RaycastAll(_playerCam.transform.position, _playerCam.transform.forward,\r\n                                             MaxPickDistance, ~layerMask);\r\n        foreach (var hit in raycastHits)\r\n        {\r\n            if (hit.collider == _player.collider || !hit.collider.rigidbody) // avoid colliding with the player object itself\r\n                continue;\r\n            _raycast = hit;\r\n        }\r\n    }\r\n\r\n    private void HoldObject()\r\n    {\r\n        if (!_heldObject)\r\n            return;\r\n        // Drag the physical avatar by changing its velocity\r\n        _heldObject.rigidbody.velocity = HeldObjectFollowStrength * (_pivot.transform.position - _heldObject.transform.position);\r\n        // When the physical avatar collides, we move the visual one to the same position. When this doesn't happen,\r\n        // move the visuals back to the pivot point.\r\n        _heldBodyAvatar.transform.position = _heldObject.IsColliding\r\n            ? _heldObject.transform.position\r\n            : _pivot.transform.position;\r\n        // If the physical avatar is colliding with something, change visuals rotation to correspond\r\n        if (_heldObject.IsColliding)\r\n            _heldBodyAvatar.transform.rotation = _heldObject.transform.rotation;\r\n    }\r\n\r\n    private void TakeObject()\r\n    {\r\n        if (!_raycast.HasValue)\r\n            return;\r\n\r\n        var heldBody = _raycast.Value.rigidbody;\r\n        heldBody.transform.position = _pivot.transform.position;\r\n        heldBody.useGravity = false;\r\n\r\n        _heldBodyAngularDrag = heldBody.angularDrag;\r\n        heldBody.angularDrag = 1; // so that the object doesn't continue rotating after each collision\r\n        heldBody.renderer.enabled = false;\r\n        _heldObject = heldBody.gameObject.AddComponent<HeldObject>();\r\n\r\n        _heldBodyAvatar = new GameObject(\"Held body avatar\");\r\n        _heldBodyAvatar.transform.parent = _playerCam.transform;\r\n        _heldBodyAvatar.transform.position = _pivot.transform.position;\r\n        _heldBodyAvatar.transform.rotation = heldBody.transform.rotation;\r\n        _heldBodyAvatar.transform.localScale = heldBody.transform.localScale;\r\n        _heldBodyAvatar.AddComponent<MeshFilter>().sharedMesh = heldBody.gameObject.GetComponent<MeshFilter>().sharedMesh;\r\n        _heldBodyAvatar.AddComponent<MeshRenderer>().sharedMaterial = heldBody.gameObject.renderer.sharedMaterial;\r\n\r\n        Physics.IgnoreCollision(heldBody.collider, Player.Controller, true);\r\n    }\r\n\r\n    private void ReleaseObject(Action onRelease = null)\r\n    {\r\n        Physics.IgnoreCollision(_heldObject.collider, Player.Controller, false);\r\n        _heldObject.rigidbody.useGravity = true;\r\n        _heldObject.rigidbody.angularDrag = _heldBodyAngularDrag;\r\n        _heldObject.rigidbody.transform.position = _heldBodyAvatar.transform.position;\r\n        _heldObject.rigidbody.transform.rotation = _heldBodyAvatar.transform.rotation;\r\n        _heldObject.rigidbody.renderer.enabled = true;\r\n        _heldBodyAvatar.renderer.enabled = false;\r\n        Destroy(_heldObject);\r\n        Destroy(_heldBodyAvatar);\r\n        if (onRelease != null)\r\n            onRelease();\r\n        _heldObject = null;\r\n    }\r\n\r\n    private void ThrowObject()\r\n    {\r\n        ReleaseObject(() => _heldObject.rigidbody.AddForce(_playerCam.transform.forward * ThrowStrength, ForceMode.Impulse));\r\n    }\r\n}`}\r\n                </Code>\r\n\r\n                <Paragraph>\r\n                    This algorithm could probably be improved by, for example, simplifying\r\n                    the <InlineCode>TakeObject</InlineCode> method. If the body that has been picked has complex\r\n                    visuals and a lot of components on it, it might be easier not to\r\n                    copy everything into a new visual avatar. Instead, you can leave the\r\n                    visuals on the object, and just create a new physical avatar. In my\r\n                    case the object itself remains physical, and all visuals go to the new object.\r\n                </Paragraph>\r\n\r\n                <Comments/>\r\n            </div>\r\n        );\r\n    }\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/pages/unity3d-pick-and-drag.js"],"sourceRoot":""}