webpackJsonp([0xa951ab5c4ccdc000],{'./node_modules/babel-loader/lib/index.js?{"plugins":["D:/dev/website-src/node_modules/gatsby/dist/utils/babel-plugin-extract-graphql.js","D:/dev/website-src/node_modules/babel-plugin-add-module-exports/lib/index.js","D:/dev/website-src/node_modules/babel-plugin-add-module-exports/lib/index.js","D:/dev/website-src/node_modules/babel-plugin-transform-object-assign/lib/index.js"],"presets":["D:/dev/website-src/node_modules/babel-preset-env/lib/index.js","D:/dev/website-src/node_modules/babel-preset-stage-0/lib/index.js","D:/dev/website-src/node_modules/babel-preset-react/lib/index.js"],"cacheDirectory":true}!./src/pages/chaiscript-recipes.js':function(e,t,n){"use strict";function a(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function s(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0}),t.title=t.date=void 0;var o=function(){function e(e,t){for(var n=0;n<t.length;n++){var a=t[n];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}return function(t,n,a){return n&&e(t.prototype,n),a&&e(t,a),t}}(),l=n("./node_modules/react/react.js"),c=a(l),u=n("./src/shared/code.js"),d=a(u),p=n("./src/shared/comments.js"),f=a(p),h=n("./src/shared/page-title.js"),m=a(h),g=n("./src/shared/section-title.js"),b=(a(g),n("./src/shared/paragraph.js")),y=a(b),v=n("./src/shared/link.js"),w=a(v),_=n("./src/shared/inline-code.js"),j=a(_),B=t.date="07 Jul 2015",E=t.title="C++ embedded scripting: ChaiScript recipes",S=function(e){function t(){return r(this,t),i(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments))}return s(t,e),o(t,[{key:"render",value:function(){return c.default.createElement("div",null,c.default.createElement(m.default,{text:E,date:B}),c.default.createElement(y.default,null,"Currently there are several options for embedding scripting into your C++ application. Among the most well-known, from my experience, are ",c.default.createElement(w.default,{to:"http://www.lua.org/"},"Lua"),", ",c.default.createElement(w.default,{to:"http://www.angelcode.com/angelscript/"},"AngelScript")," and the recent addition - ",c.default.createElement(w.default,{to:"http://chaiscript.com/"},"ChaiScript"),". I’ve been evaluating these languages for some time recently and my main impressions are:"),c.default.createElement(y.default,null,c.default.createElement("ul",null,c.default.createElement("li",null,"Lua has many binding libraries, but very few of them support smart pointers and std containers like ",c.default.createElement(j.default,null,"std::string")," at the same time (a must-have I think). Many of them are abandoned, even the most well-known LubBind (sadly). Some libraries require Boost to compile, which might not be an option for some projects. Some libraries don’t compile in MSVS 2013 (even with November CTP) due to the extensive use of C++11/14. Others have poor documentation… I personally can recommend ",c.default.createElement(w.default,{to:"https://github.com/tomaka/luawrapper"},"luawrapper")," because it has one of the richest feature sets and a fairly good documentation. Unfortunately it requires Boost and compiles in MSVS 2013 Nov CTP only after some modifications (removing ",c.default.createElement(j.default,null,"constexpr")," and ref-value qualifiers)."),c.default.createElement("li",null,"AngelScript has a built-in mechanism for embedding into C++ programs, but it looks bulky and (probably - not sure) you have to register smart pointers manually in order to use them. Overall, the syntax leaves you with many ways to make a mistake in your bindings."),c.default.createElement("li",null,"ChaiScript is a header-only engine (!), heavily template-based and increases the compilation time/binary size significantly. It is, however, designed for embedded into C++ programs and thus provides a very straightforward and transparent way of doing this. Most of the time you understand what’s going on and why. The language syntax looks like a mix of JavaScript and C++."))),c.default.createElement(y.default,null,"If you are reading this article chances are you’re deciding between those three languages, or have already chosen ChaiScript, but can’t find some necessary information in the official documentation. In this (updateable) post I’ll gather a few ChaiScript tips and code snippets that were most difficult for me to discover. They come either from long series of experiments or from the official forum and careful reading of examples and tests. This article assumes that you have already read the documentation, looked through the ",c.default.createElement(w.default,{to:"https://github.com/ChaiScript/ChaiScript/blob/master/cheatsheet.md"},"cheat sheet"),", ",c.default.createElement(w.default,{to:"https://github.com/ChaiScript/ChaiScript/tree/master/samples"},"samples")," and ",c.default.createElement(w.default,{to:"https://github.com/ChaiScript/ChaiScript/tree/master/unittests"},"unit tests"),"."),c.default.createElement(y.default,null,"Bootstrapping a project (for impatient):"),c.default.createElement(d.default,{lang:"c++"},'#include <chaiscript.hpp>\n#include <chaiscript_stdlib.hpp>\n\nint main()\n{\n    chaiscript::ChaiScript engine(chaiscript::Std_Lib::library());\n    // ... register API for your scripts\n    engine.eval_file("script.chai");\n    return 0;\n}'),c.default.createElement(y.default,null,"Attaching C++ function to a script object:"),c.default.createElement(d.default,{lang:"c++"},'// Host program\n\nvoid logMsg(chaiscript::Boxed_Value& obj, const std::string& s)\n{\n    std::cout << s << std::endl;\n}\n\n// ...\n\nengine.add(chaiscript::fun(&logMsg), "log");\n\n// Script\n\nclass Test\n{\n    def Test() {}\n}\n\nvar t := create("Test");\nt.log("abc");\n\n// Output\n\nabc'),c.default.createElement(y.default,null,"Inheritance, ",c.default.createElement(j.default,null,"shared_ptr")," to base class, polymorphic function call:"),c.default.createElement(d.default,{lang:"c++"},'// Host program\n\nstruct Base\n{\n    virtual ~Base() {} // ChaiScript requires classes to be polymorphic for inheritance to work\n};\n\nstruct A: Base\n{\n    void func()\n    {\n        LOG("A::func");\n    }\n};\n\nstruct B: Base\n{\n    void func()\n    {\n        LOG("B::func");\n    }\n};\n\n// Yes, you can pass shared_ptr to your script\nstd::shared_ptr<Base> getSmth(const std::string& name)\n{\n    if (name == "A")\n        return std::make_shared<A>();\n    if (name == "B")\n        return std::make_shared<B>();\n    return nullptr;\n}\n\n// ...\n\nengine.add(chaiscript::user_type<Base>(), "Base");\nengine.add(chaiscript::user_type<A>(), "A");\nengine.add(chaiscript::user_type<B>(), "B");\nengine.add(chaiscript::base_class<Base, A>());\nengine.add(chaiscript::base_class<Base, B>());\nengine.add(chaiscript::fun(&A::func), "func");\nengine.add(chaiscript::fun(&B::func), "func");\nengine.add(chaiscript::fun(&getSmth), "getSmth");\n\n\n// Script\n\nvar a = getSmth("A");\na.func();\n\nvar b = getSmth("B");\nb.func();\n\n// Output\n\nA::func\nB::func'),c.default.createElement(y.default,null,"Creating script object from C++, storing it, calling its functions, passing it back to script:"),c.default.createElement(d.default,{lang:"c++"},'// Host program\n\nchaiscript::Boxed_Value obj;\n\nchaiscript::Boxed_Value& create(const std::string& className)\n{\n    obj = engine.eval<chaiscript::Boxed_Value>(className + "()");\n    return obj;\n}\n\nvoid callFunc()\n{\n    // Member functions require an implicit first parameter - pointer to the object\n    auto func = engine.eval<std::function<void(chaiscript::Boxed_Value&)>>("func");\n    func(obj);\n}\n\n//...\n\nengine.add(chaiscript::fun(&create), "create");\nengine.add(chaiscript::fun(&callFunc), "callFunc");\n\n\n// Script\n\nclass Test\n{\n    var id;\n\n    def Test()\n    {\n        this.id = 0;\n    }\n\n    def func()\n    {\n        print(this.id);\n    }\n}\n\n// ":=" here is important. If it were "=", ChaiScript would create a deep copy\n// and you\'ll end up having two copies of Test object\nvar t := create("Test");\nt.id = 100500;\nt.func();\ncallFunc();\n\n// Output\n\n100500\n100500'),c.default.createElement(y.default,null,"Return any object from C++ function to ChaiScript:"),c.default.createElement(d.default,{lang:"c++"},'// Use Boxed_Value as return value\nchaiscript::Boxed_Value func(const std::string& token)\n{\n    if (token == "Foo")\n        return chaiscript::Boxed_Value(std::make_shared<Test>());\n    if (token == "Bar")\n        return chaiscript::Boxed_Value(std::string("Hello, world!"));\n    // .. and so on\n    return chaiscript::Boxed_Value(123);\n}\n\n// Register function as normal\nscript.add(chaiscript::fun(&func), "func");'),c.default.createElement(y.default,null,"That's it. I hope these recipes saved you some time."),c.default.createElement(f.default,null))}}]),t}(c.default.Component);t.default=S}});
//# sourceMappingURL=page-component---src-pages-chaiscript-recipes-js-fa3a085a8ea66d302c98.js.map