{"version":3,"sources":["webpack:///page-component---src-pages-lua-intf-js-07e5d19770deccba29fd.js","webpack:///./src/pages/lua-intf.js"],"names":["webpackJsonp","./node_modules/babel-loader/lib/index.js?{\"plugins\":[\"D:/dev/website-src/node_modules/gatsby/dist/utils/babel-plugin-extract-graphql.js\",\"D:/dev/website-src/node_modules/babel-plugin-add-module-exports/lib/index.js\",\"D:/dev/website-src/node_modules/babel-plugin-add-module-exports/lib/index.js\",\"D:/dev/website-src/node_modules/babel-plugin-transform-object-assign/lib/index.js\"],\"presets\":[\"D:/dev/website-src/node_modules/babel-preset-env/lib/index.js\",\"D:/dev/website-src/node_modules/babel-preset-stage-0/lib/index.js\",\"D:/dev/website-src/node_modules/babel-preset-react/lib/index.js\"],\"cacheDirectory\":true}!./src/pages/lua-intf.js","module","exports","__webpack_require__","_interopRequireDefault","obj","__esModule","default","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","call","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","defineProperty","title","date","undefined","_createClass","defineProperties","target","props","i","length","descriptor","key","protoProps","staticProps","_react","_react2","_code","_code2","_comments","_comments2","_pageTitle","_pageTitle2","_paragraph","_paragraph2","_link","_link2","Page","_React$Component","this","getPrototypeOf","apply","arguments","createElement","text","to","lang","Component"],"mappings":"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","file":"page-component---src-pages-lua-intf-js-07e5d19770deccba29fd.js","sourcesContent":["webpackJsonp([118364875583439550],{\n\n/***/ \"./node_modules/babel-loader/lib/index.js?{\\\"plugins\\\":[\\\"D:/dev/website-src/node_modules/gatsby/dist/utils/babel-plugin-extract-graphql.js\\\",\\\"D:/dev/website-src/node_modules/babel-plugin-add-module-exports/lib/index.js\\\",\\\"D:/dev/website-src/node_modules/babel-plugin-add-module-exports/lib/index.js\\\",\\\"D:/dev/website-src/node_modules/babel-plugin-transform-object-assign/lib/index.js\\\"],\\\"presets\\\":[\\\"D:/dev/website-src/node_modules/babel-preset-env/lib/index.js\\\",\\\"D:/dev/website-src/node_modules/babel-preset-stage-0/lib/index.js\\\",\\\"D:/dev/website-src/node_modules/babel-preset-react/lib/index.js\\\"],\\\"cacheDirectory\\\":true}!./src/pages/lua-intf.js\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.title = exports.date = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _react = __webpack_require__(\"./node_modules/react/react.js\");\n\t\n\tvar _react2 = _interopRequireDefault(_react);\n\t\n\tvar _code = __webpack_require__(\"./src/shared/code.js\");\n\t\n\tvar _code2 = _interopRequireDefault(_code);\n\t\n\tvar _comments = __webpack_require__(\"./src/shared/comments.js\");\n\t\n\tvar _comments2 = _interopRequireDefault(_comments);\n\t\n\tvar _pageTitle = __webpack_require__(\"./src/shared/page-title.js\");\n\t\n\tvar _pageTitle2 = _interopRequireDefault(_pageTitle);\n\t\n\tvar _paragraph = __webpack_require__(\"./src/shared/paragraph.js\");\n\t\n\tvar _paragraph2 = _interopRequireDefault(_paragraph);\n\t\n\tvar _link = __webpack_require__(\"./src/shared/link.js\");\n\t\n\tvar _link2 = _interopRequireDefault(_link);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar date = exports.date = '30 Sep 2015';\n\tvar title = exports.title = 'C++ embedded scripting: LuaIntf recipes';\n\t\n\tvar Page = function (_React$Component) {\n\t    _inherits(Page, _React$Component);\n\t\n\t    function Page() {\n\t        _classCallCheck(this, Page);\n\t\n\t        return _possibleConstructorReturn(this, (Page.__proto__ || Object.getPrototypeOf(Page)).apply(this, arguments));\n\t    }\n\t\n\t    _createClass(Page, [{\n\t        key: 'render',\n\t        value: function render() {\n\t            return _react2.default.createElement(\n\t                'div',\n\t                null,\n\t                _react2.default.createElement(_pageTitle2.default, { text: title, date: date }),\n\t                _react2.default.createElement(\n\t                    _paragraph2.default,\n\t                    null,\n\t                    'In my ',\n\t                    _react2.default.createElement(\n\t                        _link2.default,\n\t                        { to: '/chaiscript-recipes' },\n\t                        'previous post'\n\t                    ),\n\t                    ' on C++ embedded scripting I talked about ChaiScript and described how to implement some tricky cases when embedding this language into your C++ application. Although the language is really interesting, there are some flaws in it that I find serious, like, for example, not very rich syntax or long compilation times.'\n\t                ),\n\t                _react2.default.createElement(\n\t                    _paragraph2.default,\n\t                    null,\n\t                    'Having said that, I decided to search again in attempt to find a good Lua binding library. After some research I found one - ',\n\t                    _react2.default.createElement(\n\t                        _link2.default,\n\t                        { to: 'https://github.com/SteveKChiu/lua-intf' },\n\t                        'LuaInft'\n\t                    ),\n\t                    ' (C++11), which I want to talk about today. A good documentation (at least it has one!) plus the fact that its author positions the library as a modern remake of LuaBridge (another good, but abandoned library), attracted my attention immediately.'\n\t                ),\n\t                _react2.default.createElement(\n\t                    _paragraph2.default,\n\t                    null,\n\t                    'As with many libraries, at some point you\\u2019ll come across a task that you won\\u2019t find in the documentation. The major flaw of LuaInft is the lack of tests or samples that could shed more light on the examples of library usage, aside from rather \\u201Cgeneric\\u201D docs. This article is aimed at saving your time and fixing this particular problem. I\\u2019ll illustrate the results of my experiments with this library in a form of code examples - the way that I find most convenient for learning libraries and discovering their possibilities. Be warned: consult documentation a lot if you don\\u2019t know the very basics yet. These snippets won\\u2019t cover things that are in the docs already.'\n\t                ),\n\t                _react2.default.createElement(\n\t                    _paragraph2.default,\n\t                    null,\n\t                    'Lets start with the bare minimum - the ',\n\t                    _react2.default.createElement(\n\t                        'strong',\n\t                        null,\n\t                        'simplest, ready-to-use program running LuaIntf'\n\t                    ),\n\t                    '. Unfortunately the documentation doesn\\u2019t seem to have it in one piece:'\n\t                ),\n\t                _react2.default.createElement(\n\t                    _code2.default,\n\t                    { lang: 'c++' },\n\t                    '#include <LuaIntf.h>\\n\\nnamespace LuaIntf\\n{\\n    // Enable support for shared_ptr, vector and map.\\n    // This will allow us to use shared_ptr almost interchangeably with raw pointers,\\n    // as well as use Lua tables to handle C++ vectors and maps\\n    LUA_USING_SHARED_PTR_TYPE(std::shared_ptr)\\n    LUA_USING_LIST_TYPE(std::vector)\\n    LUA_USING_MAP_TYPE(std::map)\\n}\\n\\nint main()\\n{\\n    using namespace LuaIntf;\\n    LuaState lua;\\n    lua.openLibs();\\n    lua.doString(\"lua code here\");\\n    return 0;\\n}'\n\t                ),\n\t                _react2.default.createElement(\n\t                    _paragraph2.default,\n\t                    null,\n\t                    '(btw, setting header search paths and linking to the library is outside the scope of this article).'\n\t                ),\n\t                _react2.default.createElement(\n\t                    _paragraph2.default,\n\t                    null,\n\t                    'Let\\u2019s ',\n\t                    _react2.default.createElement(\n\t                        'strong',\n\t                        null,\n\t                        'bind some enums'\n\t                    ),\n\t                    '. Unfortunately if you Ctrl+F \\u201Cenum\\u201D in the docs, you\\u2019ll find no mentions. I can think of two ways:'\n\t                ),\n\t                _react2.default.createElement(\n\t                    _code2.default,\n\t                    { lang: 'c++' },\n\t                    'enum class TestEnum // should be no different from classic enums\\n{\\n    Value\\n};\\n\\nLuaBinding(lua).beginModule(\"test\")\\n    .addConstant(\"TestEnum_Value\", TestEnum::Value)\\n.endModule();\\n\\n// or\\n\\nLuaBinding(lua).beginModule(\"test\")\\n    .beginModule(\"TestEnum\")\\n        .addConstant(\"Value\", TestEnum::Value)\\n    .endModule()\\n.endModule();\\n\\n// Lua\\nprint(test.TestEnum_Value)\\n-- or\\nprint(test.TestEnum.Value)'\n\t                ),\n\t                _react2.default.createElement(\n\t                    _paragraph2.default,\n\t                    null,\n\t                    'The second way is probably better, because it\\u2019d allow you to easily enumerate all enum values in Lua. If it\\u2019s ever needed.'\n\t                ),\n\t                _react2.default.createElement(\n\t                    _paragraph2.default,\n\t                    null,\n\t                    'Working with ',\n\t                    _react2.default.createElement(\n\t                        'strong',\n\t                        null,\n\t                        'inheritance and smart pointers'\n\t                    ),\n\t                    ':'\n\t                ),\n\t                _react2.default.createElement(\n\t                    _code2.default,\n\t                    { lang: 'c++' },\n\t                    'class Base\\n{\\npublic:\\n    virtual ~Base() {}\\n    virtual std::string first() = 0;\\n    virtual int second() const { return 123; }\\n};\\n\\nclass A : public Base\\n{\\npublic:\\n    virtual std::string first() override { return \"Hello, world\"; }\\n    virtual int second() const override { return 2; }\\n    virtual int third() const { return 3; }\\n    int fourth() const { return 4; }\\n};\\n\\nstd::shared_ptr<Base> make()\\n{\\n    return std::make_shared<A>();\\n}\\n\\n// ...\\n\\nLuaBinding(lua).beginModule(\"test\")\\n    .beginClass<Base>(\"Base\")\\n        .addFunction(\"first\", &Base::first)\\n        .addFunction(\"second\", &Base::second)\\n    .endClass()\\n    .beginExtendClass<A, Base>(\"A\")\\n        .addFunction(\"third\", &A::third)\\n        .addFunction(\"fourth\", &A::fourth)\\n    .endClass()\\n    .addFunction(\"make\", &make)\\n.endModule();\\n\\n// Lua\\nlocal a = test.make()\\nprint(a:first())\\nprint(a:second())\\nprint(a:third())\\nprint(a:fourth())\\n\\n// Output\\nHello, world\\n2\\n3\\n4'\n\t                ),\n\t                _react2.default.createElement(\n\t                    _paragraph2.default,\n\t                    null,\n\t                    'So basically if you have a pointer to an object Lua will figure out what methods are available on it and perform downcast if needed.'\n\t                ),\n\t                _react2.default.createElement(\n\t                    _paragraph2.default,\n\t                    null,\n\t                    _react2.default.createElement(\n\t                        'strong',\n\t                        null,\n\t                        'Passing Lua objects to C++ code:'\n\t                    )\n\t                ),\n\t                _react2.default.createElement(\n\t                    _code2.default,\n\t                    { lang: 'c++' },\n\t                    'std::string acceptStuff(LuaRef luaObj,\\n    const std::vector<std::string>& stringVector,\\n    std::map<std::string, int>& dict)\\n{\\n    // Assume that this function expects Lua object (table) as first argument\\n    auto func = luaObj.get<std::function<std::string(int)>>(\"func\");\\n    auto stringField = luaObj.get<std::string>(\"str\");\\n    std::ostringstream s;\\n    s << \"func() result: \" << func(10) << \", string field value: \"\\n      << stringField << \"\\\\n\";\\n    s << \"Vector size: \" << stringVector.size() << \", first element: \"\\n      << stringVector[0] << \"\\\\n\";\\n    s << \"Dictionary size: \" << dict.size() << \", first element: (\" <<\\n        dict.begin()->first << \", \" << dict.begin()->second << \")\";\\n    return s.str();\\n}\\n\\nLuaBinding(lua).beginModule(\"test\")\\n    .addFunction(\"acceptStuff\", &acceptStuff)\\n.endModule();\\n\\n// Lua\\nlocal obj = {\\n    func = function(i)\\n        return \"You passed number \" .. i\\n    end,\\n    str = \"Hello, world\"\\n}\\nlocal v = { 1, 2, 3 }\\nlocal dict = { first = 1, second = 2 }\\nprint(test.acceptStuff(obj, v, dict))\\n\\n// Output\\nfunc() result: You passed number 10, string field value: Hello, world\\nVector size: 3, first element: 1\\nDictionary size: 2, first element: (first, 1)'\n\t                ),\n\t                _react2.default.createElement(\n\t                    _paragraph2.default,\n\t                    null,\n\t                    'Now to the interesting part: ',\n\t                    _react2.default.createElement(\n\t                        'strong',\n\t                        null,\n\t                        'attaching C++ functions to C++ objects for using inside Lua'\n\t                    ),\n\t                    '. Let\\u2019s say you want to bind a C++ class to Lua, but at some point you realize you need a few more methods in the class for use inside scripts only. An easy way would be to include those methods directly into the class or into some \\u201Cmixin\\u201D class that you would later inherit from. This is not a very good solution, at least if you\\u2019re aiming at keeping code clean, separating concerns, maintainability and flexibility. Luckily LuaIntf allows us to attach arbitrary C++ methods to a class. For instance:'\n\t                ),\n\t                _react2.default.createElement(\n\t                    _code2.default,\n\t                    { lang: 'c++' },\n\t                    'class Base\\n{\\npublic:\\n    virtual ~Base() {}\\n\\n    virtual int one() const\\n    {\\n        return 123;\\n    }\\n};\\n\\nclass A : public Base\\n{\\npublic:\\n    virtual int one() const override\\n    {\\n        return 2;\\n    }\\n\\n    int two() const\\n    {\\n        return 4;\\n    }\\n};\\n\\nstd::shared_ptr<Base> makeAsBase()\\n{\\n    return std::make_shared<A>();\\n}\\n\\nstd::shared_ptr<A> makeAsA()\\n{\\n    return std::make_shared<A>();\\n}\\n\\nint externalBaseFunc(Base* obj)\\n{\\n    return obj->one();\\n}\\n\\nint externalAFunc(A* obj)\\n{\\n    return obj->two();\\n}\\n\\nLuaBinding(lua).beginModule(\"test\")\\n    .beginClass<Base>(\"Base\")\\n        .addFunction(\"externalBaseFunc\", &externalBaseFunc)\\n    .endClass()\\n    .beginExtendClass<A, Base>(\"A\")\\n        .addFunction(\"externalAFunc\", &externalAFunc)\\n    .endClass()\\n    .addFunction(\"makeAsBase\", &makeAsBase)\\n    .addFunction(\"makeAsA\", &makeAsA)\\n.endModule();\\n\\nlua.doString(R\"s(\\n    local a = test.makeAsBase()\\n    print(a:externalBaseFunc())\\n    print(a:externalAFunc())\\n\\n    local b = test.makeAsA()\\n    print(b:externalBaseFunc())\\n    print(b:externalAFunc())\\n)s\");\\n\\n// Output:\\n2\\n4\\n2\\n4'\n\t                ),\n\t                _react2.default.createElement(\n\t                    _paragraph2.default,\n\t                    null,\n\t                    'Liked it? Then go to the ',\n\t                    _react2.default.createElement(\n\t                        _link2.default,\n\t                        { to: 'https://github.com/SteveKChiu/lua-intf' },\n\t                        'library Github'\n\t                    ),\n\t                    ' page and show it some support. Overall I think LuaIntf is a great choice in terms of feature set, but the only bad thing about this library is the lack of tests. Really, how does the author know it works?'\n\t                ),\n\t                _react2.default.createElement(_comments2.default, null)\n\t            );\n\t        }\n\t    }]);\n\t\n\t    return Page;\n\t}(_react2.default.Component);\n\t\n\texports.default = Page;\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// page-component---src-pages-lua-intf-js-07e5d19770deccba29fd.js","import React from 'react';\r\nimport Code from './../shared/code';\r\nimport Comments from './../shared/comments';\r\nimport PageTitle from './../shared/page-title';\r\nimport Paragraph from './../shared/paragraph';\r\nimport Link from './../shared/link';\r\n\r\nexport const date = '30 Sep 2015';\r\nexport const title = 'C++ embedded scripting: LuaIntf recipes';\r\n\r\nexport default class Page extends React.Component {\r\n    render() {\r\n        return (\r\n            <div>\r\n                <PageTitle text={title} date={date}/>\r\n\r\n                <Paragraph>\r\n                    In my <Link to=\"/chaiscript-recipes\">previous post</Link> on C++ embedded scripting I talked about ChaiScript and described\r\n                    how to implement some tricky cases when embedding this language into your C++ application.\r\n                    Although the language is really interesting, there are some flaws in it that I find serious,\r\n                    like, for example, not very rich syntax or long compilation times.\r\n                </Paragraph>\r\n\r\n                <Paragraph>\r\n                    Having said that, I decided to search again in attempt to find a good Lua binding library.\r\n                    After some research I found one - <Link to=\"https://github.com/SteveKChiu/lua-intf\">LuaInft</Link> (C++11),\r\n                    which I want to talk about today. A good documentation (at least it has one!) plus the\r\n                    fact that its author positions the library as a modern remake of LuaBridge (another good,\r\n                    but abandoned library), attracted my attention immediately.\r\n                </Paragraph>\r\n\r\n                <Paragraph>\r\n                    As with many libraries, at some point you’ll come across a task that you won’t\r\n                    find in the documentation. The major flaw of LuaInft is the lack of tests or samples\r\n                    that could shed more light on the examples of library usage, aside from rather “generic” docs.\r\n                    This article is aimed at saving your time and fixing this particular problem.\r\n                    I’ll illustrate the results of my experiments with this library in a form of code examples -\r\n                    the way that I find most convenient for learning libraries and discovering their possibilities.\r\n                    Be warned: consult documentation a lot if you don’t know the very basics yet.\r\n                    These snippets won’t cover things that are in the docs already.\r\n                </Paragraph>\r\n\r\n                <Paragraph>\r\n                    Lets start with the bare minimum - the <strong>simplest, ready-to-use program running\r\n                    LuaIntf</strong>. Unfortunately the documentation doesn’t seem to have it in one piece:\r\n                </Paragraph>\r\n\r\n                <Code lang=\"c++\">\r\n{`#include <LuaIntf.h>\r\n\r\nnamespace LuaIntf\r\n{\r\n    // Enable support for shared_ptr, vector and map.\r\n    // This will allow us to use shared_ptr almost interchangeably with raw pointers,\r\n    // as well as use Lua tables to handle C++ vectors and maps\r\n    LUA_USING_SHARED_PTR_TYPE(std::shared_ptr)\r\n    LUA_USING_LIST_TYPE(std::vector)\r\n    LUA_USING_MAP_TYPE(std::map)\r\n}\r\n\r\nint main()\r\n{\r\n    using namespace LuaIntf;\r\n    LuaState lua;\r\n    lua.openLibs();\r\n    lua.doString(\"lua code here\");\r\n    return 0;\r\n}`}\r\n                </Code>\r\n\r\n                <Paragraph>\r\n                    (btw, setting header search paths and linking to the library is outside the scope of this article).\r\n                </Paragraph>\r\n\r\n                <Paragraph>\r\n                    Let’s <strong>bind some enums</strong>. Unfortunately if you Ctrl+F “enum” in the docs,\r\n                    you’ll find no mentions. I can think of two ways:\r\n                </Paragraph>\r\n\r\n                <Code lang=\"c++\">\r\n{`enum class TestEnum // should be no different from classic enums\r\n{\r\n    Value\r\n};\r\n\r\nLuaBinding(lua).beginModule(\"test\")\r\n    .addConstant(\"TestEnum_Value\", TestEnum::Value)\r\n.endModule();\r\n\r\n// or\r\n\r\nLuaBinding(lua).beginModule(\"test\")\r\n    .beginModule(\"TestEnum\")\r\n        .addConstant(\"Value\", TestEnum::Value)\r\n    .endModule()\r\n.endModule();\r\n\r\n// Lua\r\nprint(test.TestEnum_Value)\r\n-- or\r\nprint(test.TestEnum.Value)`}\r\n                </Code>\r\n\r\n                <Paragraph>\r\n                    The second way is probably better, because it’d allow you to easily\r\n                    enumerate all enum values in Lua. If it’s ever needed.\r\n                </Paragraph>\r\n\r\n                <Paragraph>\r\n                    Working with <strong>inheritance and smart pointers</strong>:\r\n                </Paragraph>\r\n\r\n                <Code lang=\"c++\">\r\n{`class Base\r\n{\r\npublic:\r\n    virtual ~Base() {}\r\n    virtual std::string first() = 0;\r\n    virtual int second() const { return 123; }\r\n};\r\n\r\nclass A : public Base\r\n{\r\npublic:\r\n    virtual std::string first() override { return \"Hello, world\"; }\r\n    virtual int second() const override { return 2; }\r\n    virtual int third() const { return 3; }\r\n    int fourth() const { return 4; }\r\n};\r\n\r\nstd::shared_ptr<Base> make()\r\n{\r\n    return std::make_shared<A>();\r\n}\r\n\r\n// ...\r\n\r\nLuaBinding(lua).beginModule(\"test\")\r\n    .beginClass<Base>(\"Base\")\r\n        .addFunction(\"first\", &Base::first)\r\n        .addFunction(\"second\", &Base::second)\r\n    .endClass()\r\n    .beginExtendClass<A, Base>(\"A\")\r\n        .addFunction(\"third\", &A::third)\r\n        .addFunction(\"fourth\", &A::fourth)\r\n    .endClass()\r\n    .addFunction(\"make\", &make)\r\n.endModule();\r\n\r\n// Lua\r\nlocal a = test.make()\r\nprint(a:first())\r\nprint(a:second())\r\nprint(a:third())\r\nprint(a:fourth())\r\n\r\n// Output\r\nHello, world\r\n2\r\n3\r\n4`}\r\n                </Code>\r\n\r\n                <Paragraph>\r\n                    So basically if you have a pointer to an object Lua will figure out\r\n                    what methods are available on it and perform downcast if needed.\r\n                </Paragraph>\r\n\r\n                <Paragraph>\r\n                    <strong>Passing Lua objects to C++ code:</strong>\r\n                </Paragraph>\r\n\r\n                <Code lang=\"c++\">\r\n{`std::string acceptStuff(LuaRef luaObj,\r\n    const std::vector<std::string>& stringVector,\r\n    std::map<std::string, int>& dict)\r\n{\r\n    // Assume that this function expects Lua object (table) as first argument\r\n    auto func = luaObj.get<std::function<std::string(int)>>(\"func\");\r\n    auto stringField = luaObj.get<std::string>(\"str\");\r\n    std::ostringstream s;\r\n    s << \"func() result: \" << func(10) << \", string field value: \"\r\n      << stringField << \"\\\\n\";\r\n    s << \"Vector size: \" << stringVector.size() << \", first element: \"\r\n      << stringVector[0] << \"\\\\n\";\r\n    s << \"Dictionary size: \" << dict.size() << \", first element: (\" <<\r\n        dict.begin()->first << \", \" << dict.begin()->second << \")\";\r\n    return s.str();\r\n}\r\n\r\nLuaBinding(lua).beginModule(\"test\")\r\n    .addFunction(\"acceptStuff\", &acceptStuff)\r\n.endModule();\r\n\r\n// Lua\r\nlocal obj = {\r\n    func = function(i)\r\n        return \"You passed number \" .. i\r\n    end,\r\n    str = \"Hello, world\"\r\n}\r\nlocal v = { 1, 2, 3 }\r\nlocal dict = { first = 1, second = 2 }\r\nprint(test.acceptStuff(obj, v, dict))\r\n\r\n// Output\r\nfunc() result: You passed number 10, string field value: Hello, world\r\nVector size: 3, first element: 1\r\nDictionary size: 2, first element: (first, 1)`}\r\n                </Code>\r\n\r\n                <Paragraph>\r\n                    Now to the interesting part: <strong>attaching C++ functions to C++\r\n                    objects for using inside Lua</strong>. Let’s say you want to bind a C++ class to Lua,\r\n                    but at some point you realize you need a few more methods in the class for use\r\n                    inside scripts only. An easy way would be to include those methods directly into\r\n                    the class or into some “mixin” class that you would later inherit from.\r\n                    This is not a very good solution, at least if you’re aiming at keeping code clean,\r\n                    separating concerns, maintainability and flexibility. Luckily LuaIntf allows us\r\n                    to attach arbitrary C++ methods to a class. For instance:\r\n                </Paragraph>\r\n\r\n                <Code lang=\"c++\">\r\n{`class Base\r\n{\r\npublic:\r\n    virtual ~Base() {}\r\n\r\n    virtual int one() const\r\n    {\r\n        return 123;\r\n    }\r\n};\r\n\r\nclass A : public Base\r\n{\r\npublic:\r\n    virtual int one() const override\r\n    {\r\n        return 2;\r\n    }\r\n\r\n    int two() const\r\n    {\r\n        return 4;\r\n    }\r\n};\r\n\r\nstd::shared_ptr<Base> makeAsBase()\r\n{\r\n    return std::make_shared<A>();\r\n}\r\n\r\nstd::shared_ptr<A> makeAsA()\r\n{\r\n    return std::make_shared<A>();\r\n}\r\n\r\nint externalBaseFunc(Base* obj)\r\n{\r\n    return obj->one();\r\n}\r\n\r\nint externalAFunc(A* obj)\r\n{\r\n    return obj->two();\r\n}\r\n\r\nLuaBinding(lua).beginModule(\"test\")\r\n    .beginClass<Base>(\"Base\")\r\n        .addFunction(\"externalBaseFunc\", &externalBaseFunc)\r\n    .endClass()\r\n    .beginExtendClass<A, Base>(\"A\")\r\n        .addFunction(\"externalAFunc\", &externalAFunc)\r\n    .endClass()\r\n    .addFunction(\"makeAsBase\", &makeAsBase)\r\n    .addFunction(\"makeAsA\", &makeAsA)\r\n.endModule();\r\n\r\nlua.doString(R\"s(\r\n    local a = test.makeAsBase()\r\n    print(a:externalBaseFunc())\r\n    print(a:externalAFunc())\r\n\r\n    local b = test.makeAsA()\r\n    print(b:externalBaseFunc())\r\n    print(b:externalAFunc())\r\n)s\");\r\n\r\n// Output:\r\n2\r\n4\r\n2\r\n4`}\r\n                </Code>\r\n\r\n                <Paragraph>\r\n                    Liked it? Then go to the <Link to=\"https://github.com/SteveKChiu/lua-intf\">library Github</Link> page\r\n                    and show it some support.\r\n                    Overall I think LuaIntf is a great choice in terms of feature set,\r\n                    but the only bad thing about this library is the lack of tests.\r\n                    Really, how does the author know it works?\r\n                </Paragraph>\r\n\r\n                <Comments/>\r\n            </div>\r\n        );\r\n    }\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/pages/lua-intf.js"],"sourceRoot":""}