{"version":3,"sources":["webpack:///page-component---src-pages-nsf-devlog-2-js-f5951f8a90a5a652f8e0.js","webpack:///./src/img/nsf/player2.png?a501","webpack:///./src/img/nsf/screenshot1.png?cda4","webpack:///./src/img/nsf/screenshot2.png?f07a","webpack:///./src/pages/nsf-devlog2.js?da11"],"names":["webpackJsonp","./src/img/nsf/player2.png","module","exports","./src/img/nsf/screenshot1.png","__webpack_require__","p","./src/img/nsf/screenshot2.png","./node_modules/babel-loader/lib/index.js?{\"plugins\":[\"D:/dev/website-src/node_modules/gatsby/dist/utils/babel-plugin-extract-graphql.js\",\"D:/dev/website-src/node_modules/babel-plugin-add-module-exports/lib/index.js\",\"D:/dev/website-src/node_modules/babel-plugin-add-module-exports/lib/index.js\",\"D:/dev/website-src/node_modules/babel-plugin-transform-object-assign/lib/index.js\"],\"presets\":[\"D:/dev/website-src/node_modules/babel-preset-env/lib/index.js\",\"D:/dev/website-src/node_modules/babel-preset-stage-0/lib/index.js\",\"D:/dev/website-src/node_modules/babel-preset-react/lib/index.js\"],\"cacheDirectory\":true}!./src/pages/nsf-devlog2.js","_interopRequireDefault","obj","__esModule","default","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","call","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","defineProperty","title","date","undefined","_createClass","defineProperties","target","props","i","length","descriptor","key","protoProps","staticProps","_react","_react2","_code","_code2","_comments","_comments2","_pageTitle","_pageTitle2","_sectionTitle","_sectionTitle2","_paragraph","_paragraph2","_link","_link2","_inlineCode","_inlineCode2","_articleImages","_articleImages2","_player","_player2","_screenshot","_screenshot2","_screenshot3","_screenshot4","Page","_React$Component","this","getPrototypeOf","apply","arguments","createElement","text","images","to","lang","Component"],"mappings":"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","file":"page-component---src-pages-nsf-devlog-2-js-f5951f8a90a5a652f8e0.js","sourcesContent":["webpackJsonp([14152405270936720000],{\n\n/***/ \"./src/img/nsf/player2.png\":\n/***/ (function(module, exports) {\n\n\tmodule.exports = \"data:image/png;base64,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\"\n\n/***/ }),\n\n/***/ \"./src/img/nsf/screenshot1.png\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"static/screenshot1.488446d9.png\";\n\n/***/ }),\n\n/***/ \"./src/img/nsf/screenshot2.png\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"static/screenshot2.c0464c40.png\";\n\n/***/ }),\n\n/***/ \"./node_modules/babel-loader/lib/index.js?{\\\"plugins\\\":[\\\"D:/dev/website-src/node_modules/gatsby/dist/utils/babel-plugin-extract-graphql.js\\\",\\\"D:/dev/website-src/node_modules/babel-plugin-add-module-exports/lib/index.js\\\",\\\"D:/dev/website-src/node_modules/babel-plugin-add-module-exports/lib/index.js\\\",\\\"D:/dev/website-src/node_modules/babel-plugin-transform-object-assign/lib/index.js\\\"],\\\"presets\\\":[\\\"D:/dev/website-src/node_modules/babel-preset-env/lib/index.js\\\",\\\"D:/dev/website-src/node_modules/babel-preset-stage-0/lib/index.js\\\",\\\"D:/dev/website-src/node_modules/babel-preset-react/lib/index.js\\\"],\\\"cacheDirectory\\\":true}!./src/pages/nsf-devlog2.js\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.title = exports.date = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _react = __webpack_require__(\"./node_modules/react/react.js\");\n\t\n\tvar _react2 = _interopRequireDefault(_react);\n\t\n\tvar _code = __webpack_require__(\"./src/shared/code.js\");\n\t\n\tvar _code2 = _interopRequireDefault(_code);\n\t\n\tvar _comments = __webpack_require__(\"./src/shared/comments.js\");\n\t\n\tvar _comments2 = _interopRequireDefault(_comments);\n\t\n\tvar _pageTitle = __webpack_require__(\"./src/shared/page-title.js\");\n\t\n\tvar _pageTitle2 = _interopRequireDefault(_pageTitle);\n\t\n\tvar _sectionTitle = __webpack_require__(\"./src/shared/section-title.js\");\n\t\n\tvar _sectionTitle2 = _interopRequireDefault(_sectionTitle);\n\t\n\tvar _paragraph = __webpack_require__(\"./src/shared/paragraph.js\");\n\t\n\tvar _paragraph2 = _interopRequireDefault(_paragraph);\n\t\n\tvar _link = __webpack_require__(\"./src/shared/link.js\");\n\t\n\tvar _link2 = _interopRequireDefault(_link);\n\t\n\tvar _inlineCode = __webpack_require__(\"./src/shared/inline-code.js\");\n\t\n\tvar _inlineCode2 = _interopRequireDefault(_inlineCode);\n\t\n\tvar _articleImages = __webpack_require__(\"./src/shared/article-images.js\");\n\t\n\tvar _articleImages2 = _interopRequireDefault(_articleImages);\n\t\n\tvar _player = __webpack_require__(\"./src/img/nsf/player2.png\");\n\t\n\tvar _player2 = _interopRequireDefault(_player);\n\t\n\tvar _screenshot = __webpack_require__(\"./src/img/nsf/screenshot1.png\");\n\t\n\tvar _screenshot2 = _interopRequireDefault(_screenshot);\n\t\n\tvar _screenshot3 = __webpack_require__(\"./src/img/nsf/screenshot2.png\");\n\t\n\tvar _screenshot4 = _interopRequireDefault(_screenshot3);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar date = exports.date = '04 May 2015';\n\tvar title = exports.title = 'Not So Flat devlog, part 2';\n\t\n\tvar Page = function (_React$Component) {\n\t    _inherits(Page, _React$Component);\n\t\n\t    function Page() {\n\t        _classCallCheck(this, Page);\n\t\n\t        return _possibleConstructorReturn(this, (Page.__proto__ || Object.getPrototypeOf(Page)).apply(this, arguments));\n\t    }\n\t\n\t    _createClass(Page, [{\n\t        key: 'render',\n\t        value: function render() {\n\t            return _react2.default.createElement(\n\t                'div',\n\t                null,\n\t                _react2.default.createElement(_pageTitle2.default, { text: title, date: date }),\n\t                _react2.default.createElement(_articleImages2.default, { images: [_player2.default] }),\n\t                _react2.default.createElement(\n\t                    _paragraph2.default,\n\t                    null,\n\t                    _react2.default.createElement(\n\t                        _link2.default,\n\t                        { to: '/nsf-devlog' },\n\t                        'Part 1'\n\t                    )\n\t                ),\n\t                _react2.default.createElement(\n\t                    _paragraph2.default,\n\t                    null,\n\t                    'So, this finally happened! Not So Flat has been released and is ',\n\t                    _react2.default.createElement(\n\t                        _link2.default,\n\t                        { to: 'http://0xc0dec.itch.io/notsoflat' },\n\t                        'available for free on itch.io'\n\t                    ),\n\t                    '.'\n\t                ),\n\t                _react2.default.createElement(\n\t                    _paragraph2.default,\n\t                    null,\n\t                    'The only game before Not So Flat that also had a devlog was ultimately abandonded and never made it to the release. I was afraid Not So Flat would suffer the same fate, but things turned out (almost) very well.'\n\t                ),\n\t                _react2.default.createElement(\n\t                    _paragraph2.default,\n\t                    null,\n\t                    'This second part of the devlog is aimed at explaining the character movement implementation. This includes two major topics: the actual movement (running and jumping) and the calculation of the space available for movement.'\n\t                ),\n\t                _react2.default.createElement(_sectionTitle2.default, { text: 'Distances calculation' }),\n\t                _react2.default.createElement(\n\t                    _paragraph2.default,\n\t                    null,\n\t                    'Each frame, in order to calculate and apply a movement vector (position delta), I need to know how much room for the movement there is. To get this information, several rays are cast in all four directions from the character. For example, to calculate distance to the nearest obstacle below the character I cast three rays: one from the center of the bottom edge of the character, and two from the lower left and right corners. Having three distances calculated, the final distance in this case would be the minimum of the three. Three rays represent the character geometric dimensions and allow it, for example, to stand on a platform by touching it with a small area of the bottom edge:'\n\t                ),\n\t                _react2.default.createElement(_articleImages2.default, { images: [_screenshot2.default] }),\n\t                _react2.default.createElement(\n\t                    _paragraph2.default,\n\t                    null,\n\t                    'The three-ray approach, however, has its flaws. For example, if I made a platform that has a width of, say, 1/4 of the character width, the character would fall through it once the platform is placed right between the casted rays. For this reason, there are no platforms in the game that are narrower than the half of the character width.'\n\t                ),\n\t                _react2.default.createElement(\n\t                    _paragraph2.default,\n\t                    null,\n\t                    'Distance calculation is also required for determining whether or not the character should be wrapped around the corner. For example, a ray that is cast from the middle of the left character edge in the right direction can be used to calculate the distance between the character center and the nearest wall on the right. If the resulting distance is less than the character half-width then the character mesh gets adapted to fit into the corner. This whole procedure is quite complex and has many nuances, so I won\\u2019t go into further details here. An in-depth description probably deserves a separate blog post. Just to give you an idea of how many rays are involved:'\n\t                ),\n\t                _react2.default.createElement(_articleImages2.default, { images: [_screenshot4.default] }),\n\t                _react2.default.createElement(_sectionTitle2.default, { text: 'Running and jumping' }),\n\t                _react2.default.createElement(\n\t                    _paragraph2.default,\n\t                    null,\n\t                    'When I was approaching the character movement implementation I knew beforehand that I want the jumps to have two main features:',\n\t                    _react2.default.createElement(\n\t                        'ul',\n\t                        null,\n\t                        _react2.default.createElement(\n\t                            'li',\n\t                            null,\n\t                            'a bit of control in the air'\n\t                        ),\n\t                        _react2.default.createElement(\n\t                            'li',\n\t                            null,\n\t                            'variable height'\n\t                        )\n\t                    )\n\t                ),\n\t                _react2.default.createElement(\n\t                    _paragraph2.default,\n\t                    null,\n\t                    'There was no special reason for this, the game wasn\\u2019t built around these particular features. That was just my personal preference - I feel it very satisfying to have the ability to change movement direction while in the air.'\n\t                ),\n\t                _react2.default.createElement(\n\t                    _paragraph2.default,\n\t                    null,\n\t                    'The process can be split into two parts. The first part is responsible for the horizontal component of the movement. It is the easiest of the two and is implemented as follows:'\n\t                ),\n\t                _react2.default.createElement(\n\t                    _code2.default,\n\t                    { lang: 'csharp' },\n\t                    'private const float groundAcceleration = 10f;\\nprivate const float airAccelerationX = 5f;\\nprivate const float maxSpeedX = 4;\\n// ...\\n\\nvar accelerationX = groundAcceleration;\\nif (ContinueJumping())\\n    accelerationX = airAccelerationX;\\nif (MoveLeft ^ MoveRight)\\n    targetSpeedX = MoveRight ? maxSpeedX : MoveLeft ? -maxSpeedX : 0;\\nelse\\n    targetSpeedX = 0;\\nspeedX = Mathf.Lerp(speedX, targetSpeedX, Time.deltaTime * accelerationX);\\ndx = Time.deltaTime * speedX;'\n\t                ),\n\t                _react2.default.createElement(\n\t                    _paragraph2.default,\n\t                    null,\n\t                    'First we define the current horizontal acceleration (',\n\t                    _react2.default.createElement(\n\t                        _inlineCode2.default,\n\t                        null,\n\t                        'accelerationX'\n\t                    ),\n\t                    '). If the character is in the air (i.e. is jumping, so that the ContinueJumping() function returns ',\n\t                    _react2.default.createElement(\n\t                        _inlineCode2.default,\n\t                        null,\n\t                        'true'\n\t                    ),\n\t                    '), the acceleration gets a smaller value, which is exactly what \\u201Ca bit of control in the air\\u201D stands for. The constants are adjustable, so I can make the character be super-controllable in the air as well as make it not controllable at all.'\n\t                ),\n\t                _react2.default.createElement(\n\t                    _paragraph2.default,\n\t                    null,\n\t                    'After we\\u2019re done with the acceleration, we calculate the new horizontal speed',\n\t                    _react2.default.createElement(\n\t                        _inlineCode2.default,\n\t                        null,\n\t                        'targetSpeedX'\n\t                    ),\n\t                    ' that the character tries to reach. Since the acceleration is finite, the character doesn\\u2019t reach this speed at once - thus the name.',\n\t                    _react2.default.createElement(\n\t                        _inlineCode2.default,\n\t                        null,\n\t                        'MoveLeft'\n\t                    ),\n\t                    ' and ',\n\t                    _react2.default.createElement(\n\t                        _inlineCode2.default,\n\t                        null,\n\t                        'MoveRight'\n\t                    ),\n\t                    ' flags indicate the directions in which the player wants to move the character (simply speaking, they indicate whether or not the left and right cursor keys are being pressed). The ',\n\t                    _react2.default.createElement(\n\t                        _inlineCode2.default,\n\t                        null,\n\t                        'targetSpeedX'\n\t                    ),\n\t                    ' can only have three values: 0, ',\n\t                    _react2.default.createElement(\n\t                        _inlineCode2.default,\n\t                        null,\n\t                        '-maxSpeedX'\n\t                    ),\n\t                    ' and ',\n\t                    _react2.default.createElement(\n\t                        _inlineCode2.default,\n\t                        null,\n\t                        'maxSpeedX'\n\t                    ),\n\t                    ', which means that the character is either moving left, right, or is stopping horizontal movement at all.'\n\t                ),\n\t                _react2.default.createElement(\n\t                    _paragraph2.default,\n\t                    null,\n\t                    'The final step of the process is the calculation of the actual speed ',\n\t                    _react2.default.createElement(\n\t                        _inlineCode2.default,\n\t                        null,\n\t                        'speedX'\n\t                    ),\n\t                    '. The is done fairly simple, by calling the Lerp function, which already performs all range checks and won\\u2019t allow the speed value to go beyond the range ',\n\t                    _react2.default.createElement(\n\t                        _inlineCode2.default,\n\t                        null,\n\t                        '[-maxSpeedX, 0]'\n\t                    ),\n\t                    ' or ',\n\t                    _react2.default.createElement(\n\t                        _inlineCode2.default,\n\t                        null,\n\t                        '[0, maxSpeedX]'\n\t                    ),\n\t                    '. Having the final speed value, we calculate the horizontal position delta ',\n\t                    _react2.default.createElement(\n\t                        _inlineCode2.default,\n\t                        null,\n\t                        'dx'\n\t                    ),\n\t                    '.'\n\t                ),\n\t                _react2.default.createElement(\n\t                    _paragraph2.default,\n\t                    null,\n\t                    'The vertical component of the movement is a little bit trickier. The main difficulty comes from our wish to allow jumping by a variable height: the character jumps higher as the player presses the button longer. Let\\u2019s look at the code:'\n\t                ),\n\t                _react2.default.createElement(\n\t                    _code2.default,\n\t                    { lang: 'csharp' },\n\t                    'private const float maxDownSpeed = 12;\\nprivate const float jumpExtraGravityTime = 0.5f;\\nprivate const float jumpAccelerationDuration = 0.2f;\\nprivate float jumpTime = jumpExtraGravityTime;\\n\\n// ...\\n\\nprivate void StartJumping()\\n{\\n    if (!grounded && !jumping)\\n        canJump = false;\\n    if (!Jump && grounded)\\n        canJump = true;\\n    if (Jump && !jumping && canJump)\\n    {\\n        canJump = false;\\n        jumping = true;\\n        jumpAccelerationDone = false;\\n        grounded = false;\\n        jumpTime = 0;\\n        speedY = maxUpSpeed;\\n        // ...\\n    }\\n}\\n\\n// ...\\n\\nprivate bool ContinueJumping()\\n{\\n    if (jumping)\\n    {\\n        jumpTime += Time.deltaTime;\\n        if (!Jump || jumpTime >= jumpAccelerationDuration)\\n            jumpAccelerationDone = true;\\n    }\\n    return jumping;\\n}\\n\\n// ...\\n\\n\\nif (ContinueJumping())\\n// ...\\n\\nif (jumpAccelerationDone)\\n{\\n    var acceleration = gravityAcceleration;\\n    if (!Jump)\\n        acceleration *= 2 - Mathf.Min(1, jumpTime / jumpExtraGravityTime);\\n    speedY = Mathf.Max(speedY - Time.deltaTime * acceleration, -maxDownSpeed);\\n}\\ndy = Time.deltaTime * speedY;'\n\t                ),\n\t                _react2.default.createElement(\n\t                    _paragraph2.default,\n\t                    null,\n\t                    'The idea here is as follows. When the jump starts, we instantly set the character vertical speed to a certain maximum (as many other games do). We also keep track of how long the jump lasts (',\n\t                    _react2.default.createElement(\n\t                        _inlineCode2.default,\n\t                        null,\n\t                        'jumpTime'\n\t                    ),\n\t                    '). The first jump phase is a special acceleration phase, which lasts for ',\n\t                    _react2.default.createElement(\n\t                        _inlineCode2.default,\n\t                        null,\n\t                        'jumpAccelerationDuration'\n\t                    ),\n\t                    '. During this phase we don\\u2019t apply gravity, so the character keeps moving up with a constant maximum speed. This phase ends when either of the two events occur: 1) the ',\n\t                    _react2.default.createElement(\n\t                        _inlineCode2.default,\n\t                        null,\n\t                        'jumpTime'\n\t                    ),\n\t                    ' exceeds the ',\n\t                    _react2.default.createElement(\n\t                        _inlineCode2.default,\n\t                        null,\n\t                        'jumpAccelerationDuration'\n\t                    ),\n\t                    ' 2) the player stops pressing the jump button.'\n\t                ),\n\t                _react2.default.createElement(\n\t                    _paragraph2.default,\n\t                    null,\n\t                    'Once the acceleration phase ends, we start applying the gravity. The trick here is that the gravity value depends on the duration of the acceleration phase. If the player has been pressing the jump button for a very short amount of time, the gravity will be stronger than it would be for a longer jump. This tuning is done in the line'\n\t                ),\n\t                _react2.default.createElement(\n\t                    _code2.default,\n\t                    { lang: 'csharp' },\n\t                    'acceleration *= 2 - Mathf.Min(1, jumpTime / jumpExtraGravityTime);'\n\t                ),\n\t                _react2.default.createElement(\n\t                    _paragraph2.default,\n\t                    null,\n\t                    'I found that variable gravity, while being not realistic in theory, produces more enjoyable results in practice. As always in gamedev, I had to playtest a lot to figure out the implementation that works best for me.'\n\t                ),\n\t                _react2.default.createElement(\n\t                    _paragraph2.default,\n\t                    null,\n\t                    'Once the two components of the position delta vector are calculated, the last thing we do is determine if there\\u2019s enough space left to apply this delta, and if not, we adjust it so that the character doesn\\u2019t go through walls and other obstacles. That\\u2019s it!'\n\t                ),\n\t                _react2.default.createElement(_sectionTitle2.default, { text: 'Conclusion' }),\n\t                _react2.default.createElement(\n\t                    _paragraph2.default,\n\t                    null,\n\t                    'This post covers briefly the basic ideas behind character movement in Not So Flat. The material ended up being not very detailed, but hopefully still interesting to read. Time to work on a new game!'\n\t                ),\n\t                _react2.default.createElement(_comments2.default, null)\n\t            );\n\t        }\n\t    }]);\n\t\n\t    return Page;\n\t}(_react2.default.Component);\n\t\n\texports.default = Page;\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// page-component---src-pages-nsf-devlog-2-js-f5951f8a90a5a652f8e0.js","module.exports = \"data:image/png;base64,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\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/img/nsf/player2.png\n// module id = ./src/img/nsf/player2.png\n// module chunks = 4016850265702045000 14152405270936720000","module.exports = __webpack_public_path__ + \"static/screenshot1.488446d9.png\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/img/nsf/screenshot1.png\n// module id = ./src/img/nsf/screenshot1.png\n// module chunks = 4016850265702045000 14152405270936720000","module.exports = __webpack_public_path__ + \"static/screenshot2.c0464c40.png\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/img/nsf/screenshot2.png\n// module id = ./src/img/nsf/screenshot2.png\n// module chunks = 4016850265702045000 14152405270936720000","import React from 'react';\r\nimport Code from './../shared/code';\r\nimport Comments from './../shared/comments';\r\nimport PageTitle from './../shared/page-title';\r\nimport SectionTitle from './../shared/section-title';\r\nimport Paragraph from './../shared/paragraph';\r\nimport Link from './../shared/link';\r\nimport InlineCode from './../shared/inline-code';\r\nimport ArticleImages from './../shared/article-images';\r\n\r\nimport img1 from './../img/nsf/player2.png';\r\nimport img2 from './../img/nsf/screenshot1.png';\r\nimport img3 from './../img/nsf/screenshot2.png';\r\n\r\nexport const date = '04 May 2015';\r\nexport const title = 'Not So Flat devlog, part 2';\r\n\r\nexport default class Page extends React.Component {\r\n    render() {\r\n        return (\r\n            <div>\r\n                <PageTitle text={title} date={date}/>\r\n\r\n                <ArticleImages images={[img1]}/>\r\n\r\n                <Paragraph>\r\n                    <Link to=\"/nsf-devlog\">Part 1</Link>\r\n                </Paragraph>\r\n\r\n                <Paragraph>\r\n                    So, this finally happened! Not So Flat has been released and\r\n                    is <Link to=\"http://0xc0dec.itch.io/notsoflat\">available for free on itch.io</Link>.\r\n                </Paragraph>\r\n\r\n                <Paragraph>\r\n                    The only game before Not So Flat that also had a devlog\r\n                    was ultimately abandonded and never made it to the release.\r\n                    I was afraid Not So Flat would suffer the same fate,\r\n                    but things turned out (almost) very well.\r\n                </Paragraph>\r\n\r\n                <Paragraph>\r\n                    This second part of the devlog is aimed at explaining the character\r\n                    movement implementation. This includes two major topics: the actual\r\n                    movement (running and jumping) and the calculation of the\r\n                    space available for movement.\r\n                </Paragraph>\r\n\r\n                <SectionTitle text=\"Distances calculation\"/>\r\n\r\n                <Paragraph>\r\n                    Each frame, in order to calculate and apply a movement vector (position delta),\r\n                    I need to know how much room for the movement there is.\r\n                    To get this information, several rays are cast in all four directions\r\n                    from the character. For example, to calculate distance to the nearest\r\n                    obstacle below the character I cast three rays: one from the center of\r\n                    the bottom edge of the character, and two from the lower left and right\r\n                    corners. Having three distances calculated, the final distance in this\r\n                    case would be the minimum of the three. Three rays represent the character\r\n                    geometric dimensions and allow it, for example, to stand on a platform\r\n                    by touching it with a small area of the bottom edge:\r\n                </Paragraph>\r\n\r\n                <ArticleImages images={[img2]}/>\r\n\r\n                <Paragraph>\r\n                    The three-ray approach, however, has its flaws. For example,\r\n                    if I made a platform that has a width of, say, 1/4 of the\r\n                    character width, the character would fall through it once\r\n                    the platform is placed right between the casted rays. For this reason,\r\n                    there are no platforms in the game that are narrower than the half of the character width.\r\n                </Paragraph>\r\n\r\n                <Paragraph>\r\n                    Distance calculation is also required for determining whether or not the\r\n                    character should be wrapped around the corner. For example, a ray that\r\n                    is cast from the middle of the left character edge in the right direction\r\n                    can be used to calculate the distance between the character center and\r\n                    the nearest wall on the right. If the resulting distance is less than\r\n                    the character half-width then the character mesh gets adapted to fit into\r\n                    the corner. This whole procedure is quite complex and has many nuances,\r\n                    so I won’t go into further details here. An in-depth description probably\r\n                    deserves a separate blog post. Just to give you an idea of how many rays are involved:\r\n                </Paragraph>\r\n\r\n                <ArticleImages images={[img3]}/>\r\n\r\n                <SectionTitle text=\"Running and jumping\"/>\r\n\r\n                <Paragraph>\r\n                    When I was approaching the character movement implementation\r\n                    I knew beforehand that I want the jumps to have two main features:\r\n\r\n                    <ul>\r\n                        <li>a bit of control in the air</li>\r\n                        <li>variable height</li>\r\n                    </ul>\r\n                </Paragraph>\r\n\r\n                <Paragraph>\r\n                    There was no special reason for this, the game wasn’t built around\r\n                    these particular features. That was just my personal preference - I\r\n                    feel it very satisfying to have the ability to change movement direction while in the air.\r\n                </Paragraph>\r\n\r\n                <Paragraph>\r\n                    The process can be split into two parts. The first part is responsible for\r\n                    the horizontal component of the movement. It is the easiest of the\r\n                    two and is implemented as follows:\r\n                </Paragraph>\r\n\r\n                <Code lang=\"csharp\">\r\n{`private const float groundAcceleration = 10f;\r\nprivate const float airAccelerationX = 5f;\r\nprivate const float maxSpeedX = 4;\r\n// ...\r\n\r\nvar accelerationX = groundAcceleration;\r\nif (ContinueJumping())\r\n    accelerationX = airAccelerationX;\r\nif (MoveLeft ^ MoveRight)\r\n    targetSpeedX = MoveRight ? maxSpeedX : MoveLeft ? -maxSpeedX : 0;\r\nelse\r\n    targetSpeedX = 0;\r\nspeedX = Mathf.Lerp(speedX, targetSpeedX, Time.deltaTime * accelerationX);\r\ndx = Time.deltaTime * speedX;`}\r\n                </Code>\r\n\r\n                <Paragraph>\r\n                    First we define the current horizontal acceleration (<InlineCode>accelerationX</InlineCode>).\r\n                    If the character is in the air (i.e. is jumping, so that the ContinueJumping() function\r\n                    returns <InlineCode>true</InlineCode>), the acceleration gets a smaller value, which is exactly\r\n                    what “a bit of control in the air” stands for. The constants are adjustable,\r\n                    so I can make the character be super-controllable in the air as well as make\r\n                    it not controllable at all.\r\n                </Paragraph>\r\n\r\n                <Paragraph>\r\n                    After we’re done with the acceleration, we calculate the new horizontal speed\r\n                    <InlineCode>targetSpeedX</InlineCode> that the character tries to reach. Since the acceleration is\r\n                    finite, the character doesn’t reach this speed at once - thus the name.\r\n                    <InlineCode>MoveLeft</InlineCode> and <InlineCode>MoveRight</InlineCode> flags indicate\r\n                    the directions in which the player\r\n                    wants to move the character (simply speaking, they indicate whether or not\r\n                    the left and right cursor keys are being pressed). The <InlineCode>targetSpeedX</InlineCode> can\r\n                    only have three values: 0, <InlineCode>-maxSpeedX</InlineCode> and <InlineCode>maxSpeedX</InlineCode>,\r\n                    which means that the character is either moving left, right, or is stopping horizontal movement at all.\r\n                </Paragraph>\r\n\r\n                <Paragraph>\r\n                    The final step of the process is the calculation of the actual speed <InlineCode>speedX</InlineCode>.\r\n                    The is done fairly simple, by calling the Lerp function, which already\r\n                    performs all range checks and won’t allow the speed value to go beyond the\r\n                    range <InlineCode>[-maxSpeedX, 0]</InlineCode> or <InlineCode>[0, maxSpeedX]</InlineCode>.\r\n                    Having the final speed value, we calculate the horizontal position delta <InlineCode>dx</InlineCode>.\r\n                </Paragraph>\r\n\r\n                <Paragraph>\r\n                    The vertical component of the movement is a little bit trickier.\r\n                    The main difficulty comes from our wish to allow jumping by a variable\r\n                    height: the character jumps higher as the player presses the button longer.\r\n                    Let’s look at the code:\r\n                </Paragraph>\r\n\r\n                <Code lang=\"csharp\">\r\n{`private const float maxDownSpeed = 12;\r\nprivate const float jumpExtraGravityTime = 0.5f;\r\nprivate const float jumpAccelerationDuration = 0.2f;\r\nprivate float jumpTime = jumpExtraGravityTime;\r\n\r\n// ...\r\n\r\nprivate void StartJumping()\r\n{\r\n    if (!grounded && !jumping)\r\n        canJump = false;\r\n    if (!Jump && grounded)\r\n        canJump = true;\r\n    if (Jump && !jumping && canJump)\r\n    {\r\n        canJump = false;\r\n        jumping = true;\r\n        jumpAccelerationDone = false;\r\n        grounded = false;\r\n        jumpTime = 0;\r\n        speedY = maxUpSpeed;\r\n        // ...\r\n    }\r\n}\r\n\r\n// ...\r\n\r\nprivate bool ContinueJumping()\r\n{\r\n    if (jumping)\r\n    {\r\n        jumpTime += Time.deltaTime;\r\n        if (!Jump || jumpTime >= jumpAccelerationDuration)\r\n            jumpAccelerationDone = true;\r\n    }\r\n    return jumping;\r\n}\r\n\r\n// ...\r\n\r\n\r\nif (ContinueJumping())\r\n// ...\r\n\r\nif (jumpAccelerationDone)\r\n{\r\n    var acceleration = gravityAcceleration;\r\n    if (!Jump)\r\n        acceleration *= 2 - Mathf.Min(1, jumpTime / jumpExtraGravityTime);\r\n    speedY = Mathf.Max(speedY - Time.deltaTime * acceleration, -maxDownSpeed);\r\n}\r\ndy = Time.deltaTime * speedY;`}\r\n                </Code>\r\n\r\n                <Paragraph>\r\n                    The idea here is as follows. When the jump starts, we instantly set\r\n                    the character vertical speed to a certain maximum (as many other games do).\r\n                    We also keep track of how long the jump lasts (<InlineCode>jumpTime</InlineCode>). The first jump\r\n                    phase is a special acceleration phase, which lasts for <InlineCode>jumpAccelerationDuration</InlineCode>.\r\n                    During this phase we don’t apply gravity, so the character keeps moving\r\n                    up with a constant maximum speed. This phase ends when either of the two\r\n                    events occur: 1) the <InlineCode>jumpTime</InlineCode> exceeds the <InlineCode>jumpAccelerationDuration</InlineCode> 2)\r\n                    the player stops pressing the jump button.\r\n                </Paragraph>\r\n\r\n                <Paragraph>\r\n                    Once the acceleration phase ends, we start applying the gravity. The trick here\r\n                    is that the gravity value depends on the duration of the acceleration phase.\r\n                    If the player has been pressing the jump button for a very short amount of time,\r\n                    the gravity will be stronger than it would be for a longer jump.\r\n                    This tuning is done in the line\r\n                </Paragraph>\r\n\r\n                <Code lang=\"csharp\">\r\n{`acceleration *= 2 - Mathf.Min(1, jumpTime / jumpExtraGravityTime);`}\r\n                </Code>\r\n\r\n                <Paragraph>\r\n                    I found that variable gravity, while being not realistic in theory,\r\n                    produces more enjoyable results in practice. As always in gamedev,\r\n                    I had to playtest a lot to figure out the implementation that works best for me.\r\n                </Paragraph>\r\n\r\n                <Paragraph>\r\n                    Once the two components of the position delta vector are calculated,\r\n                    the last thing we do is determine if there’s enough space left to\r\n                    apply this delta, and if not, we adjust it so that the character\r\n                    doesn’t go through walls and other obstacles. That’s it!\r\n                </Paragraph>\r\n\r\n                <SectionTitle text=\"Conclusion\"/>\r\n\r\n                <Paragraph>\r\n                    This post covers briefly the basic ideas behind character movement in Not So Flat.\r\n                    The material ended up being not very detailed, but hopefully still interesting to read.\r\n                    Time to work on a new game!\r\n                </Paragraph>\r\n\r\n                <Comments/>\r\n            </div>\r\n        );\r\n    }\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/pages/nsf-devlog2.js"],"sourceRoot":""}