webpackJsonp([0x1a4843a2b08c2c0],{'./node_modules/babel-loader/lib/index.js?{"plugins":["D:/dev/website-src/node_modules/gatsby/dist/utils/babel-plugin-extract-graphql.js","D:/dev/website-src/node_modules/babel-plugin-add-module-exports/lib/index.js","D:/dev/website-src/node_modules/babel-plugin-add-module-exports/lib/index.js","D:/dev/website-src/node_modules/babel-plugin-transform-object-assign/lib/index.js"],"presets":["D:/dev/website-src/node_modules/babel-preset-env/lib/index.js","D:/dev/website-src/node_modules/babel-preset-stage-0/lib/index.js","D:/dev/website-src/node_modules/babel-preset-react/lib/index.js"],"cacheDirectory":true}!./src/pages/lua-intf.js':function(e,t,n){"use strict";function a(e){return e&&e.__esModule?e:{default:e}}function s(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function r(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0}),t.title=t.date=void 0;var l=function(){function e(e,t){for(var n=0;n<t.length;n++){var a=t[n];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}return function(t,n,a){return n&&e(t.prototype,n),a&&e(t,a),t}}(),o=n("./node_modules/react/react.js"),u=a(o),d=n("./src/shared/code.js"),c=a(d),f=n("./src/shared/comments.js"),m=a(f),h=n("./src/shared/page-title.js"),b=a(h),p=n("./src/shared/paragraph.js"),g=a(p),y=n("./src/shared/link.js"),w=a(y),v=t.date="30 Sep 2015",E=t.title="C++ embedded scripting: LuaIntf recipes",_=function(e){function t(){return s(this,t),i(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments))}return r(t,e),l(t,[{key:"render",value:function(){return u.default.createElement("div",null,u.default.createElement(b.default,{text:E,date:v}),u.default.createElement(g.default,null,"In my ",u.default.createElement(w.default,{to:"/chaiscript-recipes"},"previous post")," on C++ embedded scripting I talked about ChaiScript and described how to implement some tricky cases when embedding this language into your C++ application. Although the language is really interesting, there are some flaws in it that I find serious, like, for example, not very rich syntax or long compilation times."),u.default.createElement(g.default,null,"Having said that, I decided to search again in attempt to find a good Lua binding library. After some research I found one - ",u.default.createElement(w.default,{to:"https://github.com/SteveKChiu/lua-intf"},"LuaInft")," (C++11), which I want to talk about today. A good documentation (at least it has one!) plus the fact that its author positions the library as a modern remake of LuaBridge (another good, but abandoned library), attracted my attention immediately."),u.default.createElement(g.default,null,"As with many libraries, at some point you’ll come across a task that you won’t find in the documentation. The major flaw of LuaInft is the lack of tests or samples that could shed more light on the examples of library usage, aside from rather “generic” docs. This article is aimed at saving your time and fixing this particular problem. I’ll illustrate the results of my experiments with this library in a form of code examples - the way that I find most convenient for learning libraries and discovering their possibilities. Be warned: consult documentation a lot if you don’t know the very basics yet. These snippets won’t cover things that are in the docs already."),u.default.createElement(g.default,null,"Lets start with the bare minimum - the ",u.default.createElement("strong",null,"simplest, ready-to-use program running LuaIntf"),". Unfortunately the documentation doesn’t seem to have it in one piece:"),u.default.createElement(c.default,{lang:"c++"},'#include <LuaIntf.h>\n\nnamespace LuaIntf\n{\n    // Enable support for shared_ptr, vector and map.\n    // This will allow us to use shared_ptr almost interchangeably with raw pointers,\n    // as well as use Lua tables to handle C++ vectors and maps\n    LUA_USING_SHARED_PTR_TYPE(std::shared_ptr)\n    LUA_USING_LIST_TYPE(std::vector)\n    LUA_USING_MAP_TYPE(std::map)\n}\n\nint main()\n{\n    using namespace LuaIntf;\n    LuaState lua;\n    lua.openLibs();\n    lua.doString("lua code here");\n    return 0;\n}'),u.default.createElement(g.default,null,"(btw, setting header search paths and linking to the library is outside the scope of this article)."),u.default.createElement(g.default,null,"Let’s ",u.default.createElement("strong",null,"bind some enums"),". Unfortunately if you Ctrl+F “enum” in the docs, you’ll find no mentions. I can think of two ways:"),u.default.createElement(c.default,{lang:"c++"},'enum class TestEnum // should be no different from classic enums\n{\n    Value\n};\n\nLuaBinding(lua).beginModule("test")\n    .addConstant("TestEnum_Value", TestEnum::Value)\n.endModule();\n\n// or\n\nLuaBinding(lua).beginModule("test")\n    .beginModule("TestEnum")\n        .addConstant("Value", TestEnum::Value)\n    .endModule()\n.endModule();\n\n// Lua\nprint(test.TestEnum_Value)\n-- or\nprint(test.TestEnum.Value)'),u.default.createElement(g.default,null,"The second way is probably better, because it’d allow you to easily enumerate all enum values in Lua. If it’s ever needed."),u.default.createElement(g.default,null,"Working with ",u.default.createElement("strong",null,"inheritance and smart pointers"),":"),u.default.createElement(c.default,{lang:"c++"},'class Base\n{\npublic:\n    virtual ~Base() {}\n    virtual std::string first() = 0;\n    virtual int second() const { return 123; }\n};\n\nclass A : public Base\n{\npublic:\n    virtual std::string first() override { return "Hello, world"; }\n    virtual int second() const override { return 2; }\n    virtual int third() const { return 3; }\n    int fourth() const { return 4; }\n};\n\nstd::shared_ptr<Base> make()\n{\n    return std::make_shared<A>();\n}\n\n// ...\n\nLuaBinding(lua).beginModule("test")\n    .beginClass<Base>("Base")\n        .addFunction("first", &Base::first)\n        .addFunction("second", &Base::second)\n    .endClass()\n    .beginExtendClass<A, Base>("A")\n        .addFunction("third", &A::third)\n        .addFunction("fourth", &A::fourth)\n    .endClass()\n    .addFunction("make", &make)\n.endModule();\n\n// Lua\nlocal a = test.make()\nprint(a:first())\nprint(a:second())\nprint(a:third())\nprint(a:fourth())\n\n// Output\nHello, world\n2\n3\n4'),u.default.createElement(g.default,null,"So basically if you have a pointer to an object Lua will figure out what methods are available on it and perform downcast if needed."),u.default.createElement(g.default,null,u.default.createElement("strong",null,"Passing Lua objects to C++ code:")),u.default.createElement(c.default,{lang:"c++"},'std::string acceptStuff(LuaRef luaObj,\n    const std::vector<std::string>& stringVector,\n    std::map<std::string, int>& dict)\n{\n    // Assume that this function expects Lua object (table) as first argument\n    auto func = luaObj.get<std::function<std::string(int)>>("func");\n    auto stringField = luaObj.get<std::string>("str");\n    std::ostringstream s;\n    s << "func() result: " << func(10) << ", string field value: "\n      << stringField << "\\n";\n    s << "Vector size: " << stringVector.size() << ", first element: "\n      << stringVector[0] << "\\n";\n    s << "Dictionary size: " << dict.size() << ", first element: (" <<\n        dict.begin()->first << ", " << dict.begin()->second << ")";\n    return s.str();\n}\n\nLuaBinding(lua).beginModule("test")\n    .addFunction("acceptStuff", &acceptStuff)\n.endModule();\n\n// Lua\nlocal obj = {\n    func = function(i)\n        return "You passed number " .. i\n    end,\n    str = "Hello, world"\n}\nlocal v = { 1, 2, 3 }\nlocal dict = { first = 1, second = 2 }\nprint(test.acceptStuff(obj, v, dict))\n\n// Output\nfunc() result: You passed number 10, string field value: Hello, world\nVector size: 3, first element: 1\nDictionary size: 2, first element: (first, 1)'),u.default.createElement(g.default,null,"Now to the interesting part: ",u.default.createElement("strong",null,"attaching C++ functions to C++ objects for using inside Lua"),". Let’s say you want to bind a C++ class to Lua, but at some point you realize you need a few more methods in the class for use inside scripts only. An easy way would be to include those methods directly into the class or into some “mixin” class that you would later inherit from. This is not a very good solution, at least if you’re aiming at keeping code clean, separating concerns, maintainability and flexibility. Luckily LuaIntf allows us to attach arbitrary C++ methods to a class. For instance:"),u.default.createElement(c.default,{lang:"c++"},'class Base\n{\npublic:\n    virtual ~Base() {}\n\n    virtual int one() const\n    {\n        return 123;\n    }\n};\n\nclass A : public Base\n{\npublic:\n    virtual int one() const override\n    {\n        return 2;\n    }\n\n    int two() const\n    {\n        return 4;\n    }\n};\n\nstd::shared_ptr<Base> makeAsBase()\n{\n    return std::make_shared<A>();\n}\n\nstd::shared_ptr<A> makeAsA()\n{\n    return std::make_shared<A>();\n}\n\nint externalBaseFunc(Base* obj)\n{\n    return obj->one();\n}\n\nint externalAFunc(A* obj)\n{\n    return obj->two();\n}\n\nLuaBinding(lua).beginModule("test")\n    .beginClass<Base>("Base")\n        .addFunction("externalBaseFunc", &externalBaseFunc)\n    .endClass()\n    .beginExtendClass<A, Base>("A")\n        .addFunction("externalAFunc", &externalAFunc)\n    .endClass()\n    .addFunction("makeAsBase", &makeAsBase)\n    .addFunction("makeAsA", &makeAsA)\n.endModule();\n\nlua.doString(R"s(\n    local a = test.makeAsBase()\n    print(a:externalBaseFunc())\n    print(a:externalAFunc())\n\n    local b = test.makeAsA()\n    print(b:externalBaseFunc())\n    print(b:externalAFunc())\n)s");\n\n// Output:\n2\n4\n2\n4'),u.default.createElement(g.default,null,"Liked it? Then go to the ",u.default.createElement(w.default,{to:"https://github.com/SteveKChiu/lua-intf"},"library Github")," page and show it some support. Overall I think LuaIntf is a great choice in terms of feature set, but the only bad thing about this library is the lack of tests. Really, how does the author know it works?"),u.default.createElement(m.default,null))}}]),t}(u.default.Component);t.default=_}});
//# sourceMappingURL=page-component---src-pages-lua-intf-js-07e5d19770deccba29fd.js.map