webpackJsonp([0xc467719c7b8c9000],{"./src/img/nsf/player2.png":function(e,t){e.exports="data:image/png;base64,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"},"./src/img/nsf/screenshot1.png":function(e,t,a){e.exports=a.p+"static/screenshot1.488446d9.png"},"./src/img/nsf/screenshot2.png":function(e,t,a){e.exports=a.p+"static/screenshot2.c0464c40.png"},'./node_modules/babel-loader/lib/index.js?{"plugins":["D:/dev/website-src/node_modules/gatsby/dist/utils/babel-plugin-extract-graphql.js","D:/dev/website-src/node_modules/babel-plugin-add-module-exports/lib/index.js","D:/dev/website-src/node_modules/babel-plugin-add-module-exports/lib/index.js","D:/dev/website-src/node_modules/babel-plugin-transform-object-assign/lib/index.js"],"presets":["D:/dev/website-src/node_modules/babel-preset-env/lib/index.js","D:/dev/website-src/node_modules/babel-preset-stage-0/lib/index.js","D:/dev/website-src/node_modules/babel-preset-react/lib/index.js"],"cacheDirectory":true}!./src/pages/nsf-devlog2.js':function(e,t,a){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}function l(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function o(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0}),t.title=t.date=void 0;var i=function(){function e(e,t){for(var a=0;a<t.length;a++){var n=t[a];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,a,n){return a&&e(t.prototype,a),n&&e(t,n),t}}(),s=a("./node_modules/react/react.js"),c=n(s),u=a("./src/shared/code.js"),d=n(u),h=a("./src/shared/comments.js"),f=n(h),m=a("./src/shared/page-title.js"),p=n(m),g=a("./src/shared/section-title.js"),A=n(g),w=a("./src/shared/paragraph.js"),b=n(w),v=a("./src/shared/link.js"),y=n(v),E=a("./src/shared/inline-code.js"),j=n(E),C=a("./src/shared/article-images.js"),T=n(C),x=a("./src/img/nsf/player2.png"),I=n(x),S=a("./src/img/nsf/screenshot1.png"),k=n(S),J=a("./src/img/nsf/screenshot2.png"),B=n(J),D=t.date="04 May 2015",X=t.title="Not So Flat devlog, part 2",F=function(e){function t(){return l(this,t),r(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments))}return o(t,e),i(t,[{key:"render",value:function(){return c.default.createElement("div",null,c.default.createElement(p.default,{text:X,date:D}),c.default.createElement(T.default,{images:[I.default]}),c.default.createElement(b.default,null,c.default.createElement(y.default,{to:"/nsf-devlog"},"Part 1")),c.default.createElement(b.default,null,"So, this finally happened! Not So Flat has been released and is ",c.default.createElement(y.default,{to:"http://0xc0dec.itch.io/notsoflat"},"available for free on itch.io"),"."),c.default.createElement(b.default,null,"The only game before Not So Flat that also had a devlog was ultimately abandonded and never made it to the release. I was afraid Not So Flat would suffer the same fate, but things turned out (almost) very well."),c.default.createElement(b.default,null,"This second part of the devlog is aimed at explaining the character movement implementation. This includes two major topics: the actual movement (running and jumping) and the calculation of the space available for movement."),c.default.createElement(A.default,{text:"Distances calculation"}),c.default.createElement(b.default,null,"Each frame, in order to calculate and apply a movement vector (position delta), I need to know how much room for the movement there is. To get this information, several rays are cast in all four directions from the character. For example, to calculate distance to the nearest obstacle below the character I cast three rays: one from the center of the bottom edge of the character, and two from the lower left and right corners. Having three distances calculated, the final distance in this case would be the minimum of the three. Three rays represent the character geometric dimensions and allow it, for example, to stand on a platform by touching it with a small area of the bottom edge:"),c.default.createElement(T.default,{images:[k.default]}),c.default.createElement(b.default,null,"The three-ray approach, however, has its flaws. For example, if I made a platform that has a width of, say, 1/4 of the character width, the character would fall through it once the platform is placed right between the casted rays. For this reason, there are no platforms in the game that are narrower than the half of the character width."),c.default.createElement(b.default,null,"Distance calculation is also required for determining whether or not the character should be wrapped around the corner. For example, a ray that is cast from the middle of the left character edge in the right direction can be used to calculate the distance between the character center and the nearest wall on the right. If the resulting distance is less than the character half-width then the character mesh gets adapted to fit into the corner. This whole procedure is quite complex and has many nuances, so I won’t go into further details here. An in-depth description probably deserves a separate blog post. Just to give you an idea of how many rays are involved:"),c.default.createElement(T.default,{images:[B.default]}),c.default.createElement(A.default,{text:"Running and jumping"}),c.default.createElement(b.default,null,"When I was approaching the character movement implementation I knew beforehand that I want the jumps to have two main features:",c.default.createElement("ul",null,c.default.createElement("li",null,"a bit of control in the air"),c.default.createElement("li",null,"variable height"))),c.default.createElement(b.default,null,"There was no special reason for this, the game wasn’t built around these particular features. That was just my personal preference - I feel it very satisfying to have the ability to change movement direction while in the air."),c.default.createElement(b.default,null,"The process can be split into two parts. The first part is responsible for the horizontal component of the movement. It is the easiest of the two and is implemented as follows:"),c.default.createElement(d.default,{lang:"csharp"},"private const float groundAcceleration = 10f;\nprivate const float airAccelerationX = 5f;\nprivate const float maxSpeedX = 4;\n// ...\n\nvar accelerationX = groundAcceleration;\nif (ContinueJumping())\n    accelerationX = airAccelerationX;\nif (MoveLeft ^ MoveRight)\n    targetSpeedX = MoveRight ? maxSpeedX : MoveLeft ? -maxSpeedX : 0;\nelse\n    targetSpeedX = 0;\nspeedX = Mathf.Lerp(speedX, targetSpeedX, Time.deltaTime * accelerationX);\ndx = Time.deltaTime * speedX;"),c.default.createElement(b.default,null,"First we define the current horizontal acceleration (",c.default.createElement(j.default,null,"accelerationX"),"). If the character is in the air (i.e. is jumping, so that the ContinueJumping() function returns ",c.default.createElement(j.default,null,"true"),"), the acceleration gets a smaller value, which is exactly what “a bit of control in the air” stands for. The constants are adjustable, so I can make the character be super-controllable in the air as well as make it not controllable at all."),c.default.createElement(b.default,null,"After we’re done with the acceleration, we calculate the new horizontal speed",c.default.createElement(j.default,null,"targetSpeedX")," that the character tries to reach. Since the acceleration is finite, the character doesn’t reach this speed at once - thus the name.",c.default.createElement(j.default,null,"MoveLeft")," and ",c.default.createElement(j.default,null,"MoveRight")," flags indicate the directions in which the player wants to move the character (simply speaking, they indicate whether or not the left and right cursor keys are being pressed). The ",c.default.createElement(j.default,null,"targetSpeedX")," can only have three values: 0, ",c.default.createElement(j.default,null,"-maxSpeedX")," and ",c.default.createElement(j.default,null,"maxSpeedX"),", which means that the character is either moving left, right, or is stopping horizontal movement at all."),c.default.createElement(b.default,null,"The final step of the process is the calculation of the actual speed ",c.default.createElement(j.default,null,"speedX"),". The is done fairly simple, by calling the Lerp function, which already performs all range checks and won’t allow the speed value to go beyond the range ",c.default.createElement(j.default,null,"[-maxSpeedX, 0]")," or ",c.default.createElement(j.default,null,"[0, maxSpeedX]"),". Having the final speed value, we calculate the horizontal position delta ",c.default.createElement(j.default,null,"dx"),"."),c.default.createElement(b.default,null,"The vertical component of the movement is a little bit trickier. The main difficulty comes from our wish to allow jumping by a variable height: the character jumps higher as the player presses the button longer. Let’s look at the code:"),c.default.createElement(d.default,{lang:"csharp"},"private const float maxDownSpeed = 12;\nprivate const float jumpExtraGravityTime = 0.5f;\nprivate const float jumpAccelerationDuration = 0.2f;\nprivate float jumpTime = jumpExtraGravityTime;\n\n// ...\n\nprivate void StartJumping()\n{\n    if (!grounded && !jumping)\n        canJump = false;\n    if (!Jump && grounded)\n        canJump = true;\n    if (Jump && !jumping && canJump)\n    {\n        canJump = false;\n        jumping = true;\n        jumpAccelerationDone = false;\n        grounded = false;\n        jumpTime = 0;\n        speedY = maxUpSpeed;\n        // ...\n    }\n}\n\n// ...\n\nprivate bool ContinueJumping()\n{\n    if (jumping)\n    {\n        jumpTime += Time.deltaTime;\n        if (!Jump || jumpTime >= jumpAccelerationDuration)\n            jumpAccelerationDone = true;\n    }\n    return jumping;\n}\n\n// ...\n\n\nif (ContinueJumping())\n// ...\n\nif (jumpAccelerationDone)\n{\n    var acceleration = gravityAcceleration;\n    if (!Jump)\n        acceleration *= 2 - Mathf.Min(1, jumpTime / jumpExtraGravityTime);\n    speedY = Mathf.Max(speedY - Time.deltaTime * acceleration, -maxDownSpeed);\n}\ndy = Time.deltaTime * speedY;"),c.default.createElement(b.default,null,"The idea here is as follows. When the jump starts, we instantly set the character vertical speed to a certain maximum (as many other games do). We also keep track of how long the jump lasts (",c.default.createElement(j.default,null,"jumpTime"),"). The first jump phase is a special acceleration phase, which lasts for ",c.default.createElement(j.default,null,"jumpAccelerationDuration"),". During this phase we don’t apply gravity, so the character keeps moving up with a constant maximum speed. This phase ends when either of the two events occur: 1) the ",c.default.createElement(j.default,null,"jumpTime")," exceeds the ",c.default.createElement(j.default,null,"jumpAccelerationDuration")," 2) the player stops pressing the jump button."),c.default.createElement(b.default,null,"Once the acceleration phase ends, we start applying the gravity. The trick here is that the gravity value depends on the duration of the acceleration phase. If the player has been pressing the jump button for a very short amount of time, the gravity will be stronger than it would be for a longer jump. This tuning is done in the line"),c.default.createElement(d.default,{lang:"csharp"},"acceleration *= 2 - Mathf.Min(1, jumpTime / jumpExtraGravityTime);"),c.default.createElement(b.default,null,"I found that variable gravity, while being not realistic in theory, produces more enjoyable results in practice. As always in gamedev, I had to playtest a lot to figure out the implementation that works best for me."),c.default.createElement(b.default,null,"Once the two components of the position delta vector are calculated, the last thing we do is determine if there’s enough space left to apply this delta, and if not, we adjust it so that the character doesn’t go through walls and other obstacles. That’s it!"),c.default.createElement(A.default,{text:"Conclusion"}),c.default.createElement(b.default,null,"This post covers briefly the basic ideas behind character movement in Not So Flat. The material ended up being not very detailed, but hopefully still interesting to read. Time to work on a new game!"),c.default.createElement(f.default,null))}}]),t}(c.default.Component);t.default=F}});
//# sourceMappingURL=page-component---src-pages-nsf-devlog-2-js-f5951f8a90a5a652f8e0.js.map