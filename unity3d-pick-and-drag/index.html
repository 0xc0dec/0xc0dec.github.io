<!DOCTYPE html>
 <html lang="en"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="preload" href="/page-component---src-pages-unity-3-d-pick-and-drag-js-f2761a7eea84bf83e88e.js" as="script"/><link rel="preload" href="/path---unity-3-d-pick-and-drag-586c7e095e534a3909ec.js" as="script"/><link rel="preload" href="/layout-component---index-a2879b35e1f569f89061.js" as="script"/><link rel="preload" href="/app-77889474710e10931e20.js" as="script"/><link rel="preload" href="/commons-7d7dc5e746ede27497b7.js" as="script"/><script id="webpack-manifest">
            //<![CDATA[
            window.webpackManifest = {"15178676390636814000":"app-77889474710e10931e20.js","8144742166368117000":"page-component---src-pages-404-js-d1b6fe165865514a0916.js","16228548823048030000":"page-component---src-pages-about-js-5419118fa496c621aa18.js","9594620781867358000":"page-component---src-pages-artwork-js-c8e280078fd6c2791950.js","8405022255812999000":"page-component---src-pages-clion-multiple-binaries-js-80044aed22401d6f23c6.js","13387013374800785000":"page-component---src-pages-cubicroll-js-22976c655df1d72709b4.js","12200721278437278000":"page-component---src-pages-chaiscript-recipes-js-fa3a085a8ea66d302c98.js","14571134556174995000":"page-component---src-pages-freeglut-fixed-window-js-96ff9306aaf5101346a5.js","12830661747251483000":"page-component---src-pages-hwcursor-js-441b1905ed8062eb534d.js","4016850265702045000":"page-component---src-pages-index-js-44f1592a9debc885353d.js","13689988232354690000":"page-component---src-pages-line-bound-js-9f7ca68d2345cc1d6624.js","17985156244173736000":"page-component---src-pages-nether-devlog-js-4a7d4dfdf0943de86e1d.js","118364875583439550":"page-component---src-pages-lua-intf-js-07e5d19770deccba29fd.js","14152405270936720000":"page-component---src-pages-nsf-devlog-2-js-f5951f8a90a5a652f8e0.js","9169554604063220000":"page-component---src-pages-nsf-devlog-js-4de1e5a183cb5922516f.js","8002428301075783000":"page-component---src-pages-odd-cpp-js-0363c2151dc78f5033e0.js","1452333863259707600":"page-component---src-pages-nsf-js-b6084f66bc163fadbb4a.js","8423724801861283000":"page-component---src-pages-portfolio-js-db009c3b271245eb928d.js","9721245201524513000":"page-component---src-pages-projects-js-6f6b64f0aa921778af82.js","18059632766440628000":"page-component---src-pages-rebus-js-1f48aed18c2a8a760969.js","5866629043876192000":"page-component---src-pages-uncopy-js-9b0854540b537a69413c.js","12340945852327236000":"page-component---src-pages-sortvis-js-6b1b2f8790cb2126f85c.js","3059561710810546700":"page-component---src-pages-unity-3-d-array-of-custom-objects-js-20f06d86d36ac00033da.js","1570422109460401700":"page-component---src-pages-unity-3-d-pick-and-drag-js-f2761a7eea84bf83e88e.js","7013240841797279000":"page-component---src-pages-unity-3-d-spectator-camera-js-4eb43a66d856daf1319c.js","882884807161904000":"page-component---src-pages-windows-main-js-52193057b9ac89b0e032.js","16490050847094010000":"page-component---src-pages-unreal-platforms-js-1b5dc70e4e6e2b5ca564.js","6926990323429763000":"page-component---src-pages-wireframe-js-bb7f2de64d78b05285db.js","16647598582412890000":"path---404-586c7e095e534a3909ec.js","17953591736895156000":"path---about-586c7e095e534a3909ec.js","9986001659661870000":"path---artwork-586c7e095e534a3909ec.js","12625989487647412000":"path---clion-multiple-binaries-586c7e095e534a3909ec.js","12033017992842664000":"path---cubicroll-586c7e095e534a3909ec.js","7271501769925354000":"path---chaiscript-recipes-586c7e095e534a3909ec.js","13487468619723299000":"path---freeglut-fixed-window-586c7e095e534a3909ec.js","1374190494701750000":"path---hwcursor-586c7e095e534a3909ec.js","9347362237655822000":"path---index-586c7e095e534a3909ec.js","10057997867254098000":"path---line-bound-586c7e095e534a3909ec.js","11986119922783824000":"path---nether-devlog-586c7e095e534a3909ec.js","566472300682297700":"path---lua-intf-586c7e095e534a3909ec.js","6198458038639085000":"path---nsf-devlog-2-586c7e095e534a3909ec.js","14687764190454106000":"path---nsf-devlog-586c7e095e534a3909ec.js","8736120395001223000":"path---odd-cpp-586c7e095e534a3909ec.js","1816814809712808700":"path---nsf-586c7e095e534a3909ec.js","12589110883905569000":"path---portfolio-586c7e095e534a3909ec.js","6408524664133516000":"path---projects-586c7e095e534a3909ec.js","4702101129390883000":"path---rebus-586c7e095e534a3909ec.js","9838961998885528000":"path---uncopy-586c7e095e534a3909ec.js","10770882656350593000":"path---sortvis-586c7e095e534a3909ec.js","11619470239911205000":"path---unity-3-d-array-of-custom-objects-586c7e095e534a3909ec.js","15848427140066738000":"path---unity-3-d-pick-and-drag-586c7e095e534a3909ec.js","14812566356430060000":"path---unity-3-d-spectator-camera-586c7e095e534a3909ec.js","6076917203444821000":"path---windows-main-586c7e095e534a3909ec.js","12210310786293494000":"path---unreal-platforms-586c7e095e534a3909ec.js","12009341268478530000":"path---wireframe-586c7e095e534a3909ec.js","11711201792954765000":"path---404-html-586c7e095e534a3909ec.js","17241999800008180000":"layout-component---index-a2879b35e1f569f89061.js"}
            //]]>
            </script><style type="text/css" id="server-side-jss">.root-0-7 {
  margin-bottom: 40px;
}
.root-0-7 h1 {
  font-size: 2em;
  line-height: 1.5em;
}
.underline-0-8 {
  width: 100%;
  height: 1px;
  border-bottom: 1px solid #eee;
}
.date-0-9 {
  color: #b1b1b1;
  font-size: 0.9em;
  margin-bottom: 0px;
}
.root-0-12 {
  margin-bottom: 20px;
}
.root-0-4 {
  color: #0090B2;
  text-decoration: none;
}
.root-0-4:visited {
  text-decoration: none;
}
.root-0-4:focus {
  color: #0018BB;
  text-decoration: none;
}
.root-0-4:hover {
  color: #0018BB;
  text-decoration: none;
}
.disguise-0-5 {
  color: #34495e;
}
.disguise-0-5:hover {
  color: #34495e;
}
.disguise-0-5:visited {
  color: #34495e;
}
.disguise-0-5:focus {
  color: #34495e;
}
.root-0-16 {
  margin-bottom: 30px;
}
.root-0-18 {
  margin-top: 50px;
}
.normal-0-13 {
  font-size: 1.5em;
  margin-bottom: 20px;
}
.small-0-14 {
  font-size: 1.1em;
  margin-bottom: 10px;
}
.root-0-17 {
  padding: 2px 6px;
  border-radius: 4px;
  background-color: #f9f2f4;
}
.root-0-10 {
  display: flex;
  margin-top: 40px;
  margin-bottom: 40px;
  justify-content: center;
}
.fullWidth-0-11 {
  width: 100%;
  height: 100%;
}
.root-0-15 {
  display: flex;
  align-items: center;
  margin-bottom: 40px;
  justify-content: center;
}
.root-0-0 {
  width: 900px;
  margin: 0 auto;
  height: 80px;
  display: flex;
  max-width: 900px;
  align-items: center;
  flex-direction: row;
  justify-content: space-between;
}
.brand-0-1 {
  display: flex;
  align-items: center;
}
.brand-0-1 div {
  display: inline-block;
}
.logo-0-2 {
  width: 50px;
  height: 25px;
  margin-right: 20px;
  background-size: cover;
  background-image: url(data:image/png;base64,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);
  background-position: 0;
}
.menu-0-3 {
  display: flex;
  flex-direction: row;
  justify-content: space-between;
}
.menu-0-3 a {
  margin-right: 20px;
}
.menu-0-3 a:last-child {
  margin-right: 0;
}
.root-0-6 {
  width: 900px;
  margin: 30px auto 0 auto;
  max-width: 900px;
}
.root-0-19 {
  width: 100%;
  bottom: 0;
  height: 100px;
  display: flex;
  position: absolute;
  align-items: center;
}
.content-0-20 {
  width: 900px;
  margin: 0 auto;
  max-width: 900px;
}</style><title data-react-helmet="true">Unity3d tip: implementing pick-and-drag mechanics in a first-person game | Aleksey Fedotov</title><script>
  !function(e,t,r){function n(){for(;d[0]&&"loaded"==d[0][f];)c=d.shift(),c[o]=!i.parentNode.insertBefore(c,i)}for(var s,a,c,d=[],i=e.scripts[0],o="onreadystatechange",f="readyState";s=r.shift();)a=e.createElement(t),"async"in i?(a.async=!1,e.head.appendChild(a)):i[f]?(d.push(a),a[o]=n):e.write("<"+t+' src="'+s+'" defer></'+t+">"),a.src=s}(document,"script",[
  "/commons-7d7dc5e746ede27497b7.js","/app-77889474710e10931e20.js","/layout-component---index-a2879b35e1f569f89061.js","/path---unity-3-d-pick-and-drag-586c7e095e534a3909ec.js","/page-component---src-pages-unity-3-d-pick-and-drag-js-f2761a7eea84bf83e88e.js"
])
  </script><link rel="shortcut icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEwAACxMBAJqcGAAAATlJREFUWIXtlb9KA0EQhz8l4isIgSAH2ttY2UXEJ/ARRC20ibUg6U1ULOx8gVhG8AkUrEQ9BB9AUpuYU6PF7sKoO+T2jJBiP1g45rc3v5nbPweRSCQypiRAE0iBLvBZcGTAI3AMzOc137EvFjXVxhuwm8d8VIYDJV7TzBOl82VgJdC8BUwD2x4tQ1mOhpLMEVLAvn1nSdGPfAU8jKCANnBpuzwHnjEb+ezH1019BbyICXXfBMuaYn5n9QngScTnbPxQxPouWUkkls9FKAMLwBQwI+KrmKO8KGIDX4J7fnf1LvSQPXBlDU8U/dYlnRQG7dy9DqcFXAOnin7hC84CPb5X+gFUCT+GHWAPuPFoXaCiVb4ZaFRkrGvmji3g9R+Me8DGMHNHgrmYUv72X+hj7pcDzBJHIpHI+PEFo5MROikkzA0AAAAASUVORK5CYII="/><style id="gatsby-inlined-css">.hljs{display:block;overflow-x:auto;padding:.5em;color:#000;background:#f8f8ff}.hljs-comment,.hljs-quote{color:#408080;font-style:italic}.hljs-keyword,.hljs-literal,.hljs-selector-tag,.hljs-subst{color:#954121}.hljs-number{color:#40a070}.hljs-doctag,.hljs-string{color:#219161}.hljs-section,.hljs-selector-class,.hljs-selector-id,.hljs-type{color:#19469d}.hljs-params{color:#00f}.hljs-title{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-template-variable,.hljs-variable{color:teal}.hljs-link,.hljs-regexp{color:#b68}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}@font-face{font-family:OpenSans;src:url(/static/OpenSans-Regular-webfont.83efe336.eot);src:url(/static/OpenSans-Regular-webfont.83efe336.eot?#iefix) format("embedded-opentype"),url(/static/OpenSans-Regular-webfont.55b8ce1f.woff) format("woff"),url(/static/OpenSans-Regular-webfont.3cbf4d3e.ttf) format("truetype"),url(/static/OpenSans-Regular-webfont.2d13ddbb.svg#open_sansregular) format("svg");font-weight:400;font-style:normal}body,html{margin:0;padding:0;font-family:OpenSans,sans-serif;font-size:18px;line-height:31px;color:#34495e}html{position:relative;min-height:100%}body{margin-bottom:150px}h1,h2,h3,h4{margin-top:0;margin-bottom:0}iframe{border:none}</style></head><body><div id="___gatsby"><div data-reactroot="" data-reactid="1" data-react-checksum="1063609155"><div class="root-0-0" data-reactid="2"><a class="root-0-4 disguise-0-5" href="/" target="" data-reactid="3"><div class="brand-0-1" data-reactid="4"><div class="logo-0-2" data-reactid="5"></div><div data-reactid="6">// Home page of one programmer</div></div></a><div class="menu-0-3" data-reactid="7"><a class="root-0-4 " href="/" target="" data-reactid="8"><strong data-reactid="9">Articles</strong></a><a class="root-0-4 " href="/projects" target="" data-reactid="10"><strong data-reactid="11">Projects</strong></a><a class="root-0-4 " href="/about" target="" data-reactid="12"><strong data-reactid="13">About</strong></a></div></div><div class="root-0-6" data-reactid="14"><div data-reactid="15"><div class="root-0-7" data-reactid="16"><h1 data-reactid="17">Unity3d tip: implementing pick-and-drag mechanics in a first-person game</h1><div class="underline-0-8" data-reactid="18"></div><span class="date-0-9" data-reactid="19">07 Sep 2014</span><!-- react-empty: 20 --></div><div class="root-0-10" data-reactid="21"><img src="/static/companion_cube.9be1b5d8.png" class="" data-reactid="22"/></div><div class="root-0-12" data-reactid="23">Picking and dragging objects around is something that you can see quite often in various games with the first-person camera view. This features adds a lot to the level of interactivity with the game environment, so developers build their game mechanics around this feature for a good reason.</div><div class="root-0-12" data-reactid="24">So, how to implement this inside Unity? I’ve seen some implementations ranging from the very simple to the more advanced ones. In this post I’ll try to explain what I don’t like about some of them and propose my own solution with an interesting hack behind it.</div><div class="root-0-12" data-reactid="25">Lets assume that we have a camera object in the scene. It doesn’t matter how the camera is controlled, in my case it is attached to the player object. Let’s say we want, while looking through this camera, to pick objects, hold them in front of the camera, carry them around while the camera is moving, then put them to the ground or throw away. Assume picked objects to be rigid bodies. Here and throughout the rest of this article I will refer to the point to which objects are attached to while moving as the pivot point.</div><div class="root-0-12" data-reactid="26"><strong data-reactid="27">Solution 1:</strong><!-- react-text: 28 --> calculate pivot point offset each frame and move the picked object by that offset.<!-- /react-text --><br data-reactid="29"/><!-- react-text: 30 -->Pros:<!-- /react-text --><ul data-reactid="31"><li data-reactid="32">Easy to implement.</li></ul><!-- react-text: 33 -->Cons:<!-- /react-text --><ul data-reactid="34"><li data-reactid="35">Direct manipulation with the rigid body position may lead to the physics simulation instability and artifacts. It’s always a good rule to move (non-kinematic) rigid bodies by applying forces.</li></ul></div><div class="root-0-12" data-reactid="36"><strong data-reactid="37">Solution 2:</strong><!-- react-text: 38 --> make object a child of the camera.<!-- /react-text --><br data-reactid="39"/><!-- react-text: 40 -->Pros:<!-- /react-text --><ul data-reactid="41"><li data-reactid="42">Easy to implement.</li></ul><!-- react-text: 43 -->Cons:<!-- /react-text --><ul data-reactid="44"><li data-reactid="45">Same as for solution 1. (Non-kinematic) Rigid bodies should only be controlled by forces and not by direct position manipulations, which is what parent-child relationship actually does.</li></ul></div><div class="root-0-12" data-reactid="46"><strong data-reactid="47">Solution 3:</strong><!-- react-text: 48 --> use joints. Construct a joint and attach one end of it to the rigid body, and the other end to the pivot point.<!-- /react-text --><br data-reactid="49"/><!-- react-text: 50 -->Pros:<!-- /react-text --><ul data-reactid="51"><li data-reactid="52">“Physically correct” way to control the rigid body. The body follows the pivot point and is able to react to collisions.</li></ul><!-- react-text: 53 -->Cons:<!-- /react-text --><ul data-reactid="54"><li data-reactid="55">Object reaction to camera movements is laggy and twitching (lag amount depends on the joint type).</li><li data-reactid="56">Object starts to jump around the pivot point when camera makes sudden movements (true for spring joints, can be fixed by setting a high dumping value).</li><li data-reactid="57">Difficult to adjust the joint parameters to achieve somewhat of a believable result.</li></ul></div><div class="root-0-12" data-reactid="58">The solution utilising joints is the most complex of the three, but after a good tuning it produces believable results. Its main flaw for me, however, was the twitching object movement. When you drag a body that is attached to the pivot point with a fixed joint, the body is supposed to strictly preserve its position relative to the pivot point. The thing is that physical joints have “springy” nature (even if they are not spring joints), so the body will always behave a bit strange at high movement rates, twitching and slightly moving around the pivot point. What I want is to have the picked object be directly at the same spot all the time when it is dragged.</div><h2 class="normal-0-13" data-reactid="59">Solution</h2><div class="root-0-12" data-reactid="60">My solution doesn’t rely on joints. Instead, it moves the body by changing its velocity, which is also an acceptable way of moving rigid bodies. It also implements a hack that allows you to completely eliminate the body movement relative to the pivot point. You can see the final result in this video:</div><div class="root-0-15" data-reactid="61"><iframe width="640" height="360" src="//www.youtube.com/embed/zM_o6zB9B5s" frameborder="0" allowfullscreen="" data-reactid="62"></iframe></div><div class="root-0-12" data-reactid="63"><!-- react-text: 64 -->The hack is to drag <!-- /react-text --><i data-reactid="65">two</i><!-- react-text: 66 --> objects instead of one. The first object is the visual representation (avatar) of the initial body. It has no RigidBody component and is moved by directly manipulating its position. The second object is not visible at all and represents the physical aspect of the body, having a RigidBody component attached to it. Fast camera movements might somehow make it behave oddly, but the player doesn’t see it anyway. There’s no need to perform complex tweaking of the joint to make results look good (which is extremely hard from what I’ve experienced). The only tricky part is when the physical avatar collides with other objects in the scene. When this occurs, we just align the visual avatar with the physical one so that both of them react to collisions. When nothing happens, the visual avatar moves with the camera.<!-- /react-text --></div><div class="root-0-12" data-reactid="67">Below is the code with some explaining comments:</div><div class="root-0-16" data-reactid="68"><pre data-reactid="69"><code class="csharp" data-reactid="70">public class HeldObject : MonoBehaviour
{
    public bool IsColliding { get; private set; }

    private void OnCollisionEnter(Collision collision)
    {
        IsColliding = true;
    }

    private void OnTriggerStay(Collider other)
    {
        IsColliding = true;
    }

    private void OnCollisionExit(Collision collision)
    {
        IsColliding = false;
    }
}


public class PlayerPick : MonoBehaviour
{
    // Maximum distance from the camera at which the object can be picked up
    public float MaxPickDistance;
    public float ThrowStrength = 10;
    public float HeldObjectFollowStrength = 50;

    private Player _player;
    private Camera _playerCam;
    private GameObject _pivot;

    private HeldObject _heldObject; // physical avatar
    private GameObject _heldBodyAvatar; // visual avatar
    private float _heldBodyAngularDrag;

    private RaycastHit? _raycast;

    private void Start()
    {
        _player = Player.Instance;
        _playerCam = Player.Camera;
        _pivot = Player.PickPivot;
    }

    private void Update()
    {
        Raycast();
        if (Input.GetKeyDown(KeyCode.E))
        {
            if (!_heldObject)
                TakeObject();
            else
                ReleaseObject();
        }
        HoldObject();
        if (Input.GetMouseButton(0) &amp;&amp; _heldObject)
            ThrowObject();
    }

    private void Raycast()
    {
        _raycast = null;
        const int layerMask = 1 &lt;&lt; 8;
        var raycastHits = Physics.RaycastAll(_playerCam.transform.position, _playerCam.transform.forward,
                                             MaxPickDistance, ~layerMask);
        foreach (var hit in raycastHits)
        {
            if (hit.collider == _player.collider || !hit.collider.rigidbody) // avoid colliding with the player object itself
                continue;
            _raycast = hit;
        }
    }

    private void HoldObject()
    {
        if (!_heldObject)
            return;
        // Drag the physical avatar by changing its velocity
        _heldObject.rigidbody.velocity = HeldObjectFollowStrength * (_pivot.transform.position - _heldObject.transform.position);
        // When the physical avatar collides, we move the visual one to the same position. When this doesn&#x27;t happen,
        // move the visuals back to the pivot point.
        _heldBodyAvatar.transform.position = _heldObject.IsColliding
            ? _heldObject.transform.position
            : _pivot.transform.position;
        // If the physical avatar is colliding with something, change visuals rotation to correspond
        if (_heldObject.IsColliding)
            _heldBodyAvatar.transform.rotation = _heldObject.transform.rotation;
    }

    private void TakeObject()
    {
        if (!_raycast.HasValue)
            return;

        var heldBody = _raycast.Value.rigidbody;
        heldBody.transform.position = _pivot.transform.position;
        heldBody.useGravity = false;

        _heldBodyAngularDrag = heldBody.angularDrag;
        heldBody.angularDrag = 1; // so that the object doesn&#x27;t continue rotating after each collision
        heldBody.renderer.enabled = false;
        _heldObject = heldBody.gameObject.AddComponent&lt;HeldObject&gt;();

        _heldBodyAvatar = new GameObject(&quot;Held body avatar&quot;);
        _heldBodyAvatar.transform.parent = _playerCam.transform;
        _heldBodyAvatar.transform.position = _pivot.transform.position;
        _heldBodyAvatar.transform.rotation = heldBody.transform.rotation;
        _heldBodyAvatar.transform.localScale = heldBody.transform.localScale;
        _heldBodyAvatar.AddComponent&lt;MeshFilter&gt;().sharedMesh = heldBody.gameObject.GetComponent&lt;MeshFilter&gt;().sharedMesh;
        _heldBodyAvatar.AddComponent&lt;MeshRenderer&gt;().sharedMaterial = heldBody.gameObject.renderer.sharedMaterial;

        Physics.IgnoreCollision(heldBody.collider, Player.Controller, true);
    }

    private void ReleaseObject(Action onRelease = null)
    {
        Physics.IgnoreCollision(_heldObject.collider, Player.Controller, false);
        _heldObject.rigidbody.useGravity = true;
        _heldObject.rigidbody.angularDrag = _heldBodyAngularDrag;
        _heldObject.rigidbody.transform.position = _heldBodyAvatar.transform.position;
        _heldObject.rigidbody.transform.rotation = _heldBodyAvatar.transform.rotation;
        _heldObject.rigidbody.renderer.enabled = true;
        _heldBodyAvatar.renderer.enabled = false;
        Destroy(_heldObject);
        Destroy(_heldBodyAvatar);
        if (onRelease != null)
            onRelease();
        _heldObject = null;
    }

    private void ThrowObject()
    {
        ReleaseObject(() =&gt; _heldObject.rigidbody.AddForce(_playerCam.transform.forward * ThrowStrength, ForceMode.Impulse));
    }
}</code></pre></div><div class="root-0-12" data-reactid="71"><!-- react-text: 72 -->This algorithm could probably be improved by, for example, simplifying the <!-- /react-text --><code class="root-0-17" data-reactid="73">TakeObject</code><!-- react-text: 74 --> method. If the body that has been picked has complex visuals and a lot of components on it, it might be easier not to copy everything into a new visual avatar. Instead, you can leave the visuals on the object, and just create a new physical avatar. In my case the object itself remains physical, and all visuals go to the new object.<!-- /react-text --></div><div class="root-0-18" data-reactid="75"><div data-reactid="76"><div id="disqus_thread" data-reactid="77"></div></div></div></div></div><div class="root-0-19" data-reactid="78"><div class="content-0-20" data-reactid="79">© 2014-2017 Aleksey Fedotov</div></div></div></div></body></html>