webpackJsonp([0x15cb42968dce8e00],{"./src/img/companion_cube.png":function(e,t,a){e.exports=a.p+"static/companion_cube.9be1b5d8.png"},'./node_modules/babel-loader/lib/index.js?{"plugins":["D:/dev/website-src/node_modules/gatsby/dist/utils/babel-plugin-extract-graphql.js","D:/dev/website-src/node_modules/babel-plugin-add-module-exports/lib/index.js","D:/dev/website-src/node_modules/babel-plugin-add-module-exports/lib/index.js","D:/dev/website-src/node_modules/babel-plugin-transform-object-assign/lib/index.js"],"presets":["D:/dev/website-src/node_modules/babel-preset-env/lib/index.js","D:/dev/website-src/node_modules/babel-preset-stage-0/lib/index.js","D:/dev/website-src/node_modules/babel-preset-react/lib/index.js"],"cacheDirectory":true}!./src/pages/unity3d-pick-and-drag.js':function(e,t,a){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function l(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0}),t.title=t.date=void 0;var r=function(){function e(e,t){for(var a=0;a<t.length;a++){var n=t[a];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,a,n){return a&&e(t.prototype,a),n&&e(t,n),t}}(),s=a("./node_modules/react/react.js"),d=n(s),c=a("./src/shared/code.js"),h=n(c),u=a("./src/shared/comments.js"),m=n(u),p=a("./src/shared/page-title.js"),b=n(p),f=a("./src/shared/section-title.js"),y=n(f),v=a("./src/shared/paragraph.js"),g=n(v),j=a("./src/shared/inline-code.js"),w=n(j),_=a("./src/shared/article-images.js"),O=n(_),E=a("./src/shared/video.js"),B=n(E),k=a("./src/img/companion_cube.png"),C=n(k),x=t.date="07 Sep 2014",I=t.title="Unity3d tip: implementing pick-and-drag mechanics in a first-person game",P=function(e){function t(){return o(this,t),i(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments))}return l(t,e),r(t,[{key:"render",value:function(){return d.default.createElement("div",null,d.default.createElement(b.default,{text:I,date:x}),d.default.createElement(O.default,{images:[C.default]}),d.default.createElement(g.default,null,"Picking and dragging objects around is something that you can see quite often in various games with the first-person camera view. This features adds a lot to the level of interactivity with the game environment, so developers build their game mechanics around this feature for a good reason."),d.default.createElement(g.default,null,"So, how to implement this inside Unity? I’ve seen some implementations ranging from the very simple to the more advanced ones. In this post I’ll try to explain what I don’t like about some of them and propose my own solution with an interesting hack behind it."),d.default.createElement(g.default,null,"Lets assume that we have a camera object in the scene. It doesn’t matter how the camera is controlled, in my case it is attached to the player object. Let’s say we want, while looking through this camera, to pick objects, hold them in front of the camera, carry them around while the camera is moving, then put them to the ground or throw away. Assume picked objects to be rigid bodies. Here and throughout the rest of this article I will refer to the point to which objects are attached to while moving as the pivot point."),d.default.createElement(g.default,null,d.default.createElement("strong",null,"Solution 1:")," calculate pivot point offset each frame and move the picked object by that offset.",d.default.createElement("br",null),"Pros:",d.default.createElement("ul",null,d.default.createElement("li",null,"Easy to implement.")),"Cons:",d.default.createElement("ul",null,d.default.createElement("li",null,"Direct manipulation with the rigid body position may lead to the physics simulation instability and artifacts. It’s always a good rule to move (non-kinematic) rigid bodies by applying forces."))),d.default.createElement(g.default,null,d.default.createElement("strong",null,"Solution 2:")," make object a child of the camera.",d.default.createElement("br",null),"Pros:",d.default.createElement("ul",null,d.default.createElement("li",null,"Easy to implement.")),"Cons:",d.default.createElement("ul",null,d.default.createElement("li",null,"Same as for solution 1. (Non-kinematic) Rigid bodies should only be controlled by forces and not by direct position manipulations, which is what parent-child relationship actually does."))),d.default.createElement(g.default,null,d.default.createElement("strong",null,"Solution 3:")," use joints. Construct a joint and attach one end of it to the rigid body, and the other end to the pivot point.",d.default.createElement("br",null),"Pros:",d.default.createElement("ul",null,d.default.createElement("li",null,"“Physically correct” way to control the rigid body. The body follows the pivot point and is able to react to collisions.")),"Cons:",d.default.createElement("ul",null,d.default.createElement("li",null,"Object reaction to camera movements is laggy and twitching (lag amount depends on the joint type)."),d.default.createElement("li",null,"Object starts to jump around the pivot point when camera makes sudden movements (true for spring joints, can be fixed by setting a high dumping value)."),d.default.createElement("li",null,"Difficult to adjust the joint parameters to achieve somewhat of a believable result."))),d.default.createElement(g.default,null,"The solution utilising joints is the most complex of the three, but after a good tuning it produces believable results. Its main flaw for me, however, was the twitching object movement. When you drag a body that is attached to the pivot point with a fixed joint, the body is supposed to strictly preserve its position relative to the pivot point. The thing is that physical joints have “springy” nature (even if they are not spring joints), so the body will always behave a bit strange at high movement rates, twitching and slightly moving around the pivot point. What I want is to have the picked object be directly at the same spot all the time when it is dragged."),d.default.createElement(y.default,{text:"Solution"}),d.default.createElement(g.default,null,"My solution doesn’t rely on joints. Instead, it moves the body by changing its velocity, which is also an acceptable way of moving rigid bodies. It also implements a hack that allows you to completely eliminate the body movement relative to the pivot point. You can see the final result in this video:"),d.default.createElement(B.default,{src:"//www.youtube.com/embed/zM_o6zB9B5s"}),d.default.createElement(g.default,null,"The hack is to drag ",d.default.createElement("i",null,"two")," objects instead of one. The first object is the visual representation (avatar) of the initial body. It has no RigidBody component and is moved by directly manipulating its position. The second object is not visible at all and represents the physical aspect of the body, having a RigidBody component attached to it. Fast camera movements might somehow make it behave oddly, but the player doesn’t see it anyway. There’s no need to perform complex tweaking of the joint to make results look good (which is extremely hard from what I’ve experienced). The only tricky part is when the physical avatar collides with other objects in the scene. When this occurs, we just align the visual avatar with the physical one so that both of them react to collisions. When nothing happens, the visual avatar moves with the camera."),d.default.createElement(g.default,null,"Below is the code with some explaining comments:"),d.default.createElement(h.default,{lang:"csharp"},"public class HeldObject : MonoBehaviour\n{\n    public bool IsColliding { get; private set; }\n\n    private void OnCollisionEnter(Collision collision)\n    {\n        IsColliding = true;\n    }\n\n    private void OnTriggerStay(Collider other)\n    {\n        IsColliding = true;\n    }\n\n    private void OnCollisionExit(Collision collision)\n    {\n        IsColliding = false;\n    }\n}\n\n\npublic class PlayerPick : MonoBehaviour\n{\n    // Maximum distance from the camera at which the object can be picked up\n    public float MaxPickDistance;\n    public float ThrowStrength = 10;\n    public float HeldObjectFollowStrength = 50;\n\n    private Player _player;\n    private Camera _playerCam;\n    private GameObject _pivot;\n\n    private HeldObject _heldObject; // physical avatar\n    private GameObject _heldBodyAvatar; // visual avatar\n    private float _heldBodyAngularDrag;\n\n    private RaycastHit? _raycast;\n\n    private void Start()\n    {\n        _player = Player.Instance;\n        _playerCam = Player.Camera;\n        _pivot = Player.PickPivot;\n    }\n\n    private void Update()\n    {\n        Raycast();\n        if (Input.GetKeyDown(KeyCode.E))\n        {\n            if (!_heldObject)\n                TakeObject();\n            else\n                ReleaseObject();\n        }\n        HoldObject();\n        if (Input.GetMouseButton(0) && _heldObject)\n            ThrowObject();\n    }\n\n    private void Raycast()\n    {\n        _raycast = null;\n        const int layerMask = 1 << 8;\n        var raycastHits = Physics.RaycastAll(_playerCam.transform.position, _playerCam.transform.forward,\n                                             MaxPickDistance, ~layerMask);\n        foreach (var hit in raycastHits)\n        {\n            if (hit.collider == _player.collider || !hit.collider.rigidbody) // avoid colliding with the player object itself\n                continue;\n            _raycast = hit;\n        }\n    }\n\n    private void HoldObject()\n    {\n        if (!_heldObject)\n            return;\n        // Drag the physical avatar by changing its velocity\n        _heldObject.rigidbody.velocity = HeldObjectFollowStrength * (_pivot.transform.position - _heldObject.transform.position);\n        // When the physical avatar collides, we move the visual one to the same position. When this doesn't happen,\n        // move the visuals back to the pivot point.\n        _heldBodyAvatar.transform.position = _heldObject.IsColliding\n            ? _heldObject.transform.position\n            : _pivot.transform.position;\n        // If the physical avatar is colliding with something, change visuals rotation to correspond\n        if (_heldObject.IsColliding)\n            _heldBodyAvatar.transform.rotation = _heldObject.transform.rotation;\n    }\n\n    private void TakeObject()\n    {\n        if (!_raycast.HasValue)\n            return;\n\n        var heldBody = _raycast.Value.rigidbody;\n        heldBody.transform.position = _pivot.transform.position;\n        heldBody.useGravity = false;\n\n        _heldBodyAngularDrag = heldBody.angularDrag;\n        heldBody.angularDrag = 1; // so that the object doesn't continue rotating after each collision\n        heldBody.renderer.enabled = false;\n        _heldObject = heldBody.gameObject.AddComponent<HeldObject>();\n\n        _heldBodyAvatar = new GameObject(\"Held body avatar\");\n        _heldBodyAvatar.transform.parent = _playerCam.transform;\n        _heldBodyAvatar.transform.position = _pivot.transform.position;\n        _heldBodyAvatar.transform.rotation = heldBody.transform.rotation;\n        _heldBodyAvatar.transform.localScale = heldBody.transform.localScale;\n        _heldBodyAvatar.AddComponent<MeshFilter>().sharedMesh = heldBody.gameObject.GetComponent<MeshFilter>().sharedMesh;\n        _heldBodyAvatar.AddComponent<MeshRenderer>().sharedMaterial = heldBody.gameObject.renderer.sharedMaterial;\n\n        Physics.IgnoreCollision(heldBody.collider, Player.Controller, true);\n    }\n\n    private void ReleaseObject(Action onRelease = null)\n    {\n        Physics.IgnoreCollision(_heldObject.collider, Player.Controller, false);\n        _heldObject.rigidbody.useGravity = true;\n        _heldObject.rigidbody.angularDrag = _heldBodyAngularDrag;\n        _heldObject.rigidbody.transform.position = _heldBodyAvatar.transform.position;\n        _heldObject.rigidbody.transform.rotation = _heldBodyAvatar.transform.rotation;\n        _heldObject.rigidbody.renderer.enabled = true;\n        _heldBodyAvatar.renderer.enabled = false;\n        Destroy(_heldObject);\n        Destroy(_heldBodyAvatar);\n        if (onRelease != null)\n            onRelease();\n        _heldObject = null;\n    }\n\n    private void ThrowObject()\n    {\n        ReleaseObject(() => _heldObject.rigidbody.AddForce(_playerCam.transform.forward * ThrowStrength, ForceMode.Impulse));\n    }\n}"),d.default.createElement(g.default,null,"This algorithm could probably be improved by, for example, simplifying the ",d.default.createElement(w.default,null,"TakeObject")," method. If the body that has been picked has complex visuals and a lot of components on it, it might be easier not to copy everything into a new visual avatar. Instead, you can leave the visuals on the object, and just create a new physical avatar. In my case the object itself remains physical, and all visuals go to the new object."),d.default.createElement(m.default,null))}}]),t}(d.default.Component);t.default=P}});
//# sourceMappingURL=page-component---src-pages-unity-3-d-pick-and-drag-js-f2761a7eea84bf83e88e.js.map