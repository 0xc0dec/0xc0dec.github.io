webpackJsonp([0x74a4a335befc7800],{"./src/img/clion/logo.png":function(e,t,l){e.exports=l.p+"static/logo.bf7ee2bb.png"},"./src/img/clion/project.png":function(e,t,l){e.exports=l.p+"static/project.29667d0c.png"},'./node_modules/babel-loader/lib/index.js?{"plugins":["D:/dev/website-src/node_modules/gatsby/dist/utils/babel-plugin-extract-graphql.js","D:/dev/website-src/node_modules/babel-plugin-add-module-exports/lib/index.js","D:/dev/website-src/node_modules/babel-plugin-add-module-exports/lib/index.js","D:/dev/website-src/node_modules/babel-plugin-transform-object-assign/lib/index.js"],"presets":["D:/dev/website-src/node_modules/babel-preset-env/lib/index.js","D:/dev/website-src/node_modules/babel-preset-stage-0/lib/index.js","D:/dev/website-src/node_modules/babel-preset-react/lib/index.js"],"cacheDirectory":true}!./src/pages/clion-multiple-binaries.js':function(e,t,l){"use strict";function a(e){return e&&e.__esModule?e:{default:e}}function n(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function r(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0}),t.title=t.date=void 0;var o=function(){function e(e,t){for(var l=0;l<t.length;l++){var a=t[l];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}return function(t,l,a){return l&&e(t.prototype,l),a&&e(t,a),t}}(),s=l("./node_modules/react/react.js"),d=a(s),u=l("./src/shared/code.js"),c=a(u),f=l("./src/shared/comments.js"),b=a(f),m=l("./src/shared/page-title.js"),p=a(m),h=l("./src/shared/section-title.js"),_=a(h),g=l("./src/shared/paragraph.js"),E=a(g),y=l("./src/shared/link.js"),k=a(y),C=l("./src/shared/inline-code.js"),w=a(C),T=l("./src/shared/article-images.js"),O=a(T),j=l("./src/img/clion/logo.png"),R=a(j),v=l("./src/img/clion/project.png"),x=a(v),I=t.date="19 Oct 2014",L=t.title="Building multiple linked binaries in CLion on Mac OS X",$=function(e){function t(){return n(this,t),i(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments))}return r(t,e),o(t,[{key:"render",value:function(){return d.default.createElement("div",null,d.default.createElement(p.default,{text:L,date:I}),d.default.createElement(O.default,{images:[R.default]}),d.default.createElement(E.default,null,d.default.createElement(k.default,{to:"https://www.jetbrains.com/clion/"},"CLion")," is a new C/C++ IDE from JetBrains, the creators of ReSharper, IntelliJ IDEA and many other great products for software developers. CLion is claimed to support a full-featured refactoring workflow for C++, similar to how it is already implemented in other JetBrains products. At this moment the IDE is available in early access mode, which means that we can download and use it freely, keeping in mind that the product is not stable yet, so bugs are possible."),d.default.createElement(E.default,null,"I decided to move one of my projects from XCode to CLion. The refactoring capabilities of XCode for C++ are far from being good (in fact, there is no refactoring support for C++), and after using ReSharper for my C# projects, I simply don’t understand how to work without “Rename”, “Find usages”, “Generate missing members”, smart highlighting and a plenty of other super-useful features."),d.default.createElement(E.default,null,"CLion uses CMake to describe and manage its projects (at least yet). If you’re not very familiar with CMake (like me), creating and building anything more complex than the default Hello world will be sort of a nightmare. In this post I’ll share my experience in building a static library and a project that uses this library in CLion, hoping that this will save a lot of googling time for anyone having the similar task."),d.default.createElement(E.default,null,"For example, we want to build a static library named solo and a test project Test1 that links against it. My project structure looks like this:"),d.default.createElement(O.default,{images:[x.default]}),d.default.createElement(E.default,null,"The ",d.default.createElement(w.default,null,"src")," folder contains the library source files and the ",d.default.createElement(w.default,null,"include")," folder contains the interface headers. The ",d.default.createElement(w.default,null,"Test1")," project resides inside the ",d.default.createElement(w.default,null,"tests/test1")," folder. I’m using a single ",d.default.createElement(w.default,null,"CMakeLists.txt")," for everything for the sake of simplicity. As the project grows bigger, you might consider splitting it into several ",d.default.createElement(w.default,null,"CMakeLists’")," to make it modular and easier to manage."),d.default.createElement(E.default,null,"Lets examine the ",d.default.createElement(w.default,null,"CMakeLists.txt")," file. The first two lines are added by CLion by default:"),d.default.createElement(c.default,{lang:"cmake"},"cmake_minimum_required(VERSION 2.8.4)\nproject(solo)"),d.default.createElement(E.default,null,"They state that we want CMake version to be at least 2.8.4, and our project is called ",d.default.createElement(w.default,null,"solo"),"."),d.default.createElement(E.default,null,"Here comes the first interesting part: we tell CLion where to save the output binaries. By default, they are put into some wierd location like ",d.default.createElement(w.default,null,"/Users/<username>/Library/Caches/clion10/cmake/generated/707a014b/707a014b/Debug"),". Here we want to store them in some more conventional place like the build folder inside the project folder:"),d.default.createElement(c.default,{lang:"cmake"},'set(EXECUTABLE_OUTPUT_PATH "${PROJECT_SOURCE_DIR}/build/")\nset(LIBRARY_OUTPUT_PATH "${PROJECT_SOURCE_DIR}/build/")'),d.default.createElement(E.default,null,"The next line tells CMake to pass specific flags to the Clang compiler:"),d.default.createElement(c.default,{lang:"cmake"},"add_compile_options(-std=c++0x)"),d.default.createElement(E.default,null,"Our library needs some headers to compile, so we tell CMake to search them in a number of directores:"),d.default.createElement(c.default,{lang:"cmake"},"include_directories(\n    ${PROJECT_SOURCE_DIR}/include\n    ${PROJECT_SOURCE_DIR}/external/SDL/2.0.3/include)"),d.default.createElement(E.default,null,"Here the ",d.default.createElement(w.default,null,"${PROJECT_SOURCE_DIR}")," refers to the root project folder."),d.default.createElement(E.default,null,"We also need to specify where to look for the external libraries when linking our library against them:"),d.default.createElement(c.default,{lang:"cmake"},"link_directories(${PROJECT_SOURCE_DIR}/external/SDL/2.0.3)"),d.default.createElement(E.default,null,"Next we tell CMake to find all ",d.default.createElement(w.default,null,"*.cpp")," files inside the src folder and put them into the ",d.default.createElement(w.default,null,"sources")," variable:"),d.default.createElement(c.default,{lang:"cmake"},'file(GLOB sources "src/*.cpp")'),d.default.createElement(E.default,null,"In the next chunk of code we tell CMake to find some frameworks that we’re going to be using, and save their paths to the frameworks variable:"),d.default.createElement(c.default,{lang:"cmake"},"find_library(carbon_lib Carbon) # we look for the Carbon framework and use carbon_lib as an alias for it\nfind_library(iokit_lib IOKit)\nfind_library(forcefeedback_lib ForceFeedback)\nfind_library(cocoa_lib Cocoa)\nfind_library(audiounit_lib AudioUnit)\nfind_library(coreaudio_lib CoreAudio)\nfind_library(opengl_lib OpenGL)\nfind_library(corefoundation_lib CoreFoundation)\n\nset(frameworks\n    ${carbon_lib}\n    ${iokit_lib}\n    ${forcefeedback_lib}\n    ${cocoa_lib}\n    ${audiounit_lib}\n    ${coreaudio_lib}\n    ${opengl_lib}\n    ${corefoundation_lib})"),d.default.createElement(E.default,null,"Finally, we say that we want to build a static library from the given sources and link it against the SDL2 library and the frameworks that we found before:"),d.default.createElement(c.default,{lang:"cmake"},"add_library(solo STATIC ${sources})\ntarget_link_libraries(solo SDL2 ${frameworks})"),d.default.createElement(E.default,null,"Adding the second binary (the ",d.default.createElement(w.default,null,"Test1")," executable) is as easy as it is. We tell CMake to build it from the ",d.default.createElement(w.default,null,"Main.cpp")," file and link agains the ",d.default.createElement(w.default,null,"solo")," library:"),d.default.createElement(c.default,{lang:"cmake"},"add_executable(Test1 tests/test1/Main.cpp)\ntarget_link_libraries(Test1 LINK_PUBLIC solo)"),d.default.createElement(E.default,null,"Now if you hit ",d.default.createElement(w.default,null,"Cmd + F9")," (Build), you should see two new files inside the build folder: ",d.default.createElement(w.default,null,"Test1")," and ",d.default.createElement(w.default,null,"libsolo.a"),"."),d.default.createElement(E.default,null,"The whole ",d.default.createElement(w.default,null,"CMakeLists.txt")," file:"),d.default.createElement(c.default,{lang:"cmake"},'cmake_minimum_required(VERSION 2.8.4)\nproject(solo)\n\nset(EXECUTABLE_OUTPUT_PATH "${PROJECT_SOURCE_DIR}/build/")\nset(LIBRARY_OUTPUT_PATH "${PROJECT_SOURCE_DIR}/build/")\n\nadd_compile_options(-std=c++0x)\n\ninclude_directories(\n    ${PROJECT_SOURCE_DIR}/include\n    ${PROJECT_SOURCE_DIR}/external/SDL/2.0.3/include)\n\nlink_directories(${PROJECT_SOURCE_DIR}/external/SDL/2.0.3)\n\n# Engine\n\nfile(GLOB sources "src/*.cpp")\n\nfind_library(carbon_lib Carbon)\nfind_library(iokit_lib IOKit)\nfind_library(forcefeedback_lib ForceFeedback)\nfind_library(cocoa_lib Cocoa)\nfind_library(audiounit_lib AudioUnit)\nfind_library(coreaudio_lib CoreAudio)\nfind_library(opengl_lib OpenGL)\nfind_library(corefoundation_lib CoreFoundation)\n\nset(frameworks\n    ${carbon_lib}\n    ${iokit_lib}\n    ${forcefeedback_lib}\n    ${cocoa_lib}\n    ${audiounit_lib}\n    ${coreaudio_lib}\n    ${opengl_lib}\n    ${corefoundation_lib})\n\nadd_library(solo STATIC ${sources})\ntarget_link_libraries(solo SDL2 ${frameworks})\n\n# Tests\nadd_executable(Test1 tests/test1/Main.cpp)\ntarget_link_libraries(Test1 LINK_PUBLIC solo)'),d.default.createElement(_.default,{text:"Conclusion"}),d.default.createElement(E.default,null,"This article gives a recipe for writing a simple CMake file for building two linked binaries in CLion. Keep in mind that I’m not an expert in CMake, neither in Clion, so the given file might not be the best that you can make to get the job done. However, it gives a good start for working with CLion, which, as I have noticed, is not well covered in the online tutorials yet."),d.default.createElement(b.default,null))}}]),t}(d.default.Component);t.default=$}});
//# sourceMappingURL=page-component---src-pages-clion-multiple-binaries-js-80044aed22401d6f23c6.js.map