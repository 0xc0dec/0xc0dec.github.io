{"version":3,"sources":["webpack:///page-component---src-pages-chaiscript-recipes-js-fa3a085a8ea66d302c98.js","webpack:///./src/pages/chaiscript-recipes.js?958f"],"names":["webpackJsonp","./node_modules/babel-loader/lib/index.js?{\"plugins\":[\"D:/dev/website-src/node_modules/gatsby/dist/utils/babel-plugin-extract-graphql.js\",\"D:/dev/website-src/node_modules/babel-plugin-add-module-exports/lib/index.js\",\"D:/dev/website-src/node_modules/babel-plugin-add-module-exports/lib/index.js\",\"D:/dev/website-src/node_modules/babel-plugin-transform-object-assign/lib/index.js\"],\"presets\":[\"D:/dev/website-src/node_modules/babel-preset-env/lib/index.js\",\"D:/dev/website-src/node_modules/babel-preset-stage-0/lib/index.js\",\"D:/dev/website-src/node_modules/babel-preset-react/lib/index.js\"],\"cacheDirectory\":true}!./src/pages/chaiscript-recipes.js","module","exports","__webpack_require__","_interopRequireDefault","obj","__esModule","default","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","call","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","defineProperty","title","date","undefined","_createClass","defineProperties","target","props","i","length","descriptor","key","protoProps","staticProps","_react","_react2","_code","_code2","_comments","_comments2","_pageTitle","_pageTitle2","_sectionTitle","_paragraph","_paragraph2","_link","_link2","_inlineCode","_inlineCode2","Page","_React$Component","this","getPrototypeOf","apply","arguments","createElement","text","to","lang","Component"],"mappings":"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","file":"page-component---src-pages-chaiscript-recipes-js-fa3a085a8ea66d302c98.js","sourcesContent":["webpackJsonp([12200721278437278000],{\n\n/***/ \"./node_modules/babel-loader/lib/index.js?{\\\"plugins\\\":[\\\"D:/dev/website-src/node_modules/gatsby/dist/utils/babel-plugin-extract-graphql.js\\\",\\\"D:/dev/website-src/node_modules/babel-plugin-add-module-exports/lib/index.js\\\",\\\"D:/dev/website-src/node_modules/babel-plugin-add-module-exports/lib/index.js\\\",\\\"D:/dev/website-src/node_modules/babel-plugin-transform-object-assign/lib/index.js\\\"],\\\"presets\\\":[\\\"D:/dev/website-src/node_modules/babel-preset-env/lib/index.js\\\",\\\"D:/dev/website-src/node_modules/babel-preset-stage-0/lib/index.js\\\",\\\"D:/dev/website-src/node_modules/babel-preset-react/lib/index.js\\\"],\\\"cacheDirectory\\\":true}!./src/pages/chaiscript-recipes.js\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.title = exports.date = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _react = __webpack_require__(\"./node_modules/react/react.js\");\n\t\n\tvar _react2 = _interopRequireDefault(_react);\n\t\n\tvar _code = __webpack_require__(\"./src/shared/code.js\");\n\t\n\tvar _code2 = _interopRequireDefault(_code);\n\t\n\tvar _comments = __webpack_require__(\"./src/shared/comments.js\");\n\t\n\tvar _comments2 = _interopRequireDefault(_comments);\n\t\n\tvar _pageTitle = __webpack_require__(\"./src/shared/page-title.js\");\n\t\n\tvar _pageTitle2 = _interopRequireDefault(_pageTitle);\n\t\n\tvar _sectionTitle = __webpack_require__(\"./src/shared/section-title.js\");\n\t\n\tvar _sectionTitle2 = _interopRequireDefault(_sectionTitle);\n\t\n\tvar _paragraph = __webpack_require__(\"./src/shared/paragraph.js\");\n\t\n\tvar _paragraph2 = _interopRequireDefault(_paragraph);\n\t\n\tvar _link = __webpack_require__(\"./src/shared/link.js\");\n\t\n\tvar _link2 = _interopRequireDefault(_link);\n\t\n\tvar _inlineCode = __webpack_require__(\"./src/shared/inline-code.js\");\n\t\n\tvar _inlineCode2 = _interopRequireDefault(_inlineCode);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar date = exports.date = '07 Jul 2015';\n\tvar title = exports.title = 'C++ embedded scripting: ChaiScript recipes';\n\t\n\tvar Page = function (_React$Component) {\n\t    _inherits(Page, _React$Component);\n\t\n\t    function Page() {\n\t        _classCallCheck(this, Page);\n\t\n\t        return _possibleConstructorReturn(this, (Page.__proto__ || Object.getPrototypeOf(Page)).apply(this, arguments));\n\t    }\n\t\n\t    _createClass(Page, [{\n\t        key: 'render',\n\t        value: function render() {\n\t            return _react2.default.createElement(\n\t                'div',\n\t                null,\n\t                _react2.default.createElement(_pageTitle2.default, { text: title, date: date }),\n\t                _react2.default.createElement(\n\t                    _paragraph2.default,\n\t                    null,\n\t                    'Currently there are several options for embedding scripting into your C++ application. Among the most well-known, from my experience, are ',\n\t                    _react2.default.createElement(\n\t                        _link2.default,\n\t                        { to: 'http://www.lua.org/' },\n\t                        'Lua'\n\t                    ),\n\t                    ', ',\n\t                    _react2.default.createElement(\n\t                        _link2.default,\n\t                        { to: 'http://www.angelcode.com/angelscript/' },\n\t                        'AngelScript'\n\t                    ),\n\t                    ' and the recent addition - ',\n\t                    _react2.default.createElement(\n\t                        _link2.default,\n\t                        { to: 'http://chaiscript.com/' },\n\t                        'ChaiScript'\n\t                    ),\n\t                    '. I\\u2019ve been evaluating these languages for some time recently and my main impressions are:'\n\t                ),\n\t                _react2.default.createElement(\n\t                    _paragraph2.default,\n\t                    null,\n\t                    _react2.default.createElement(\n\t                        'ul',\n\t                        null,\n\t                        _react2.default.createElement(\n\t                            'li',\n\t                            null,\n\t                            'Lua has many binding libraries, but very few of them support smart pointers and std containers like ',\n\t                            _react2.default.createElement(\n\t                                _inlineCode2.default,\n\t                                null,\n\t                                'std::string'\n\t                            ),\n\t                            ' at the same time (a must-have I think). Many of them are abandoned, even the most well-known LubBind (sadly). Some libraries require Boost to compile, which might not be an option for some projects. Some libraries don\\u2019t compile in MSVS 2013 (even with November CTP) due to the extensive use of C++11/14. Others have poor documentation\\u2026 I personally can recommend ',\n\t                            _react2.default.createElement(\n\t                                _link2.default,\n\t                                { to: 'https://github.com/tomaka/luawrapper' },\n\t                                'luawrapper'\n\t                            ),\n\t                            ' because it has one of the richest feature sets and a fairly good documentation. Unfortunately it requires Boost and compiles in MSVS 2013 Nov CTP only after some modifications (removing ',\n\t                            _react2.default.createElement(\n\t                                _inlineCode2.default,\n\t                                null,\n\t                                'constexpr'\n\t                            ),\n\t                            ' and ref-value qualifiers).'\n\t                        ),\n\t                        _react2.default.createElement(\n\t                            'li',\n\t                            null,\n\t                            'AngelScript has a built-in mechanism for embedding into C++ programs, but it looks bulky and (probably - not sure) you have to register smart pointers manually in order to use them. Overall, the syntax leaves you with many ways to make a mistake in your bindings.'\n\t                        ),\n\t                        _react2.default.createElement(\n\t                            'li',\n\t                            null,\n\t                            'ChaiScript is a header-only engine (!), heavily template-based and increases the compilation time/binary size significantly. It is, however, designed for embedded into C++ programs and thus provides a very straightforward and transparent way of doing this. Most of the time you understand what\\u2019s going on and why. The language syntax looks like a mix of JavaScript and C++.'\n\t                        )\n\t                    )\n\t                ),\n\t                _react2.default.createElement(\n\t                    _paragraph2.default,\n\t                    null,\n\t                    'If you are reading this article chances are you\\u2019re deciding between those three languages, or have already chosen ChaiScript, but can\\u2019t find some necessary information in the official documentation. In this (updateable) post I\\u2019ll gather a few ChaiScript tips and code snippets that were most difficult for me to discover. They come either from long series of experiments or from the official forum and careful reading of examples and tests. This article assumes that you have already read the documentation, looked through the ',\n\t                    _react2.default.createElement(\n\t                        _link2.default,\n\t                        { to: 'https://github.com/ChaiScript/ChaiScript/blob/master/cheatsheet.md' },\n\t                        'cheat sheet'\n\t                    ),\n\t                    ', ',\n\t                    _react2.default.createElement(\n\t                        _link2.default,\n\t                        { to: 'https://github.com/ChaiScript/ChaiScript/tree/master/samples' },\n\t                        'samples'\n\t                    ),\n\t                    ' and ',\n\t                    _react2.default.createElement(\n\t                        _link2.default,\n\t                        { to: 'https://github.com/ChaiScript/ChaiScript/tree/master/unittests' },\n\t                        'unit tests'\n\t                    ),\n\t                    '.'\n\t                ),\n\t                _react2.default.createElement(\n\t                    _paragraph2.default,\n\t                    null,\n\t                    'Bootstrapping a project (for impatient):'\n\t                ),\n\t                _react2.default.createElement(\n\t                    _code2.default,\n\t                    { lang: 'c++' },\n\t                    '#include <chaiscript.hpp>\\n#include <chaiscript_stdlib.hpp>\\n\\nint main()\\n{\\n    chaiscript::ChaiScript engine(chaiscript::Std_Lib::library());\\n    // ... register API for your scripts\\n    engine.eval_file(\"script.chai\");\\n    return 0;\\n}'\n\t                ),\n\t                _react2.default.createElement(\n\t                    _paragraph2.default,\n\t                    null,\n\t                    'Attaching C++ function to a script object:'\n\t                ),\n\t                _react2.default.createElement(\n\t                    _code2.default,\n\t                    { lang: 'c++' },\n\t                    '// Host program\\n\\nvoid logMsg(chaiscript::Boxed_Value& obj, const std::string& s)\\n{\\n    std::cout << s << std::endl;\\n}\\n\\n// ...\\n\\nengine.add(chaiscript::fun(&logMsg), \"log\");\\n\\n// Script\\n\\nclass Test\\n{\\n    def Test() {}\\n}\\n\\nvar t := create(\"Test\");\\nt.log(\"abc\");\\n\\n// Output\\n\\nabc'\n\t                ),\n\t                _react2.default.createElement(\n\t                    _paragraph2.default,\n\t                    null,\n\t                    'Inheritance, ',\n\t                    _react2.default.createElement(\n\t                        _inlineCode2.default,\n\t                        null,\n\t                        'shared_ptr'\n\t                    ),\n\t                    ' to base class, polymorphic function call:'\n\t                ),\n\t                _react2.default.createElement(\n\t                    _code2.default,\n\t                    { lang: 'c++' },\n\t                    '// Host program\\n\\nstruct Base\\n{\\n    virtual ~Base() {} // ChaiScript requires classes to be polymorphic for inheritance to work\\n};\\n\\nstruct A: Base\\n{\\n    void func()\\n    {\\n        LOG(\"A::func\");\\n    }\\n};\\n\\nstruct B: Base\\n{\\n    void func()\\n    {\\n        LOG(\"B::func\");\\n    }\\n};\\n\\n// Yes, you can pass shared_ptr to your script\\nstd::shared_ptr<Base> getSmth(const std::string& name)\\n{\\n    if (name == \"A\")\\n        return std::make_shared<A>();\\n    if (name == \"B\")\\n        return std::make_shared<B>();\\n    return nullptr;\\n}\\n\\n// ...\\n\\nengine.add(chaiscript::user_type<Base>(), \"Base\");\\nengine.add(chaiscript::user_type<A>(), \"A\");\\nengine.add(chaiscript::user_type<B>(), \"B\");\\nengine.add(chaiscript::base_class<Base, A>());\\nengine.add(chaiscript::base_class<Base, B>());\\nengine.add(chaiscript::fun(&A::func), \"func\");\\nengine.add(chaiscript::fun(&B::func), \"func\");\\nengine.add(chaiscript::fun(&getSmth), \"getSmth\");\\n\\n\\n// Script\\n\\nvar a = getSmth(\"A\");\\na.func();\\n\\nvar b = getSmth(\"B\");\\nb.func();\\n\\n// Output\\n\\nA::func\\nB::func'\n\t                ),\n\t                _react2.default.createElement(\n\t                    _paragraph2.default,\n\t                    null,\n\t                    'Creating script object from C++, storing it, calling its functions, passing it back to script:'\n\t                ),\n\t                _react2.default.createElement(\n\t                    _code2.default,\n\t                    { lang: 'c++' },\n\t                    '// Host program\\n\\nchaiscript::Boxed_Value obj;\\n\\nchaiscript::Boxed_Value& create(const std::string& className)\\n{\\n    obj = engine.eval<chaiscript::Boxed_Value>(className + \"()\");\\n    return obj;\\n}\\n\\nvoid callFunc()\\n{\\n    // Member functions require an implicit first parameter - pointer to the object\\n    auto func = engine.eval<std::function<void(chaiscript::Boxed_Value&)>>(\"func\");\\n    func(obj);\\n}\\n\\n//...\\n\\nengine.add(chaiscript::fun(&create), \"create\");\\nengine.add(chaiscript::fun(&callFunc), \"callFunc\");\\n\\n\\n// Script\\n\\nclass Test\\n{\\n    var id;\\n\\n    def Test()\\n    {\\n        this.id = 0;\\n    }\\n\\n    def func()\\n    {\\n        print(this.id);\\n    }\\n}\\n\\n// \":=\" here is important. If it were \"=\", ChaiScript would create a deep copy\\n// and you\\'ll end up having two copies of Test object\\nvar t := create(\"Test\");\\nt.id = 100500;\\nt.func();\\ncallFunc();\\n\\n// Output\\n\\n100500\\n100500'\n\t                ),\n\t                _react2.default.createElement(\n\t                    _paragraph2.default,\n\t                    null,\n\t                    'Return any object from C++ function to ChaiScript:'\n\t                ),\n\t                _react2.default.createElement(\n\t                    _code2.default,\n\t                    { lang: 'c++' },\n\t                    '// Use Boxed_Value as return value\\nchaiscript::Boxed_Value func(const std::string& token)\\n{\\n    if (token == \"Foo\")\\n        return chaiscript::Boxed_Value(std::make_shared<Test>());\\n    if (token == \"Bar\")\\n        return chaiscript::Boxed_Value(std::string(\"Hello, world!\"));\\n    // .. and so on\\n    return chaiscript::Boxed_Value(123);\\n}\\n\\n// Register function as normal\\nscript.add(chaiscript::fun(&func), \"func\");'\n\t                ),\n\t                _react2.default.createElement(\n\t                    _paragraph2.default,\n\t                    null,\n\t                    'That\\'s it. I hope these recipes saved you some time.'\n\t                ),\n\t                _react2.default.createElement(_comments2.default, null)\n\t            );\n\t        }\n\t    }]);\n\t\n\t    return Page;\n\t}(_react2.default.Component);\n\t\n\texports.default = Page;\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// page-component---src-pages-chaiscript-recipes-js-fa3a085a8ea66d302c98.js","import React from 'react';\r\nimport Code from './../shared/code';\r\nimport Comments from './../shared/comments';\r\nimport PageTitle from './../shared/page-title';\r\nimport SectionTitle from './../shared/section-title';\r\nimport Paragraph from './../shared/paragraph';\r\nimport Link from './../shared/link';\r\nimport InlineCode from './../shared/inline-code';\r\n\r\nexport const date = '07 Jul 2015';\r\nexport const title = 'C++ embedded scripting: ChaiScript recipes';\r\n\r\nexport default class Page extends React.Component {\r\n    render() {\r\n        return (\r\n            <div>\r\n                <PageTitle text={title} date={date}/>\r\n\r\n                <Paragraph>\r\n                    Currently there are several options for embedding scripting into your C++ application.\r\n                    Among the most well-known, from my experience, are <Link to=\"http://www.lua.org/\">Lua</Link>, <Link to=\"http://www.angelcode.com/angelscript/\">AngelScript</Link> and\r\n                    the recent addition - <Link to=\"http://chaiscript.com/\">ChaiScript</Link>.\r\n                    I’ve been evaluating these languages for some time recently and my main impressions are:\r\n                </Paragraph>\r\n\r\n                <Paragraph>\r\n                    <ul>\r\n                        <li>\r\n                            Lua has many binding libraries, but very few of them support smart\r\n                            pointers and std containers like <InlineCode>std::string</InlineCode> at the same time\r\n                            (a must-have I think). Many of them are abandoned, even the most well-known\r\n                            LubBind (sadly). Some libraries require Boost to compile, which might not\r\n                            be an option for some projects. Some libraries don’t compile in MSVS 2013\r\n                            (even with November CTP) due to the extensive use of C++11/14.\r\n                            Others have poor documentation… I personally can\r\n                            recommend <Link to=\"https://github.com/tomaka/luawrapper\">luawrapper</Link> because\r\n                            it has one of the richest feature sets and a fairly good documentation.\r\n                            Unfortunately it requires Boost and compiles in MSVS 2013 Nov CTP only after\r\n                            some modifications (removing <InlineCode>constexpr</InlineCode> and ref-value qualifiers).\r\n                        </li>\r\n\r\n                        <li>\r\n                            AngelScript has a built-in mechanism for embedding into C++ programs,\r\n                            but it looks bulky and (probably - not sure) you have to register smart\r\n                            pointers manually in order to use them. Overall, the syntax leaves you\r\n                            with many ways to make a mistake in your bindings.\r\n                        </li>\r\n\r\n                        <li>\r\n                            ChaiScript is a header-only engine (!), heavily template-based and increases\r\n                            the compilation time/binary size significantly. It is, however, designed\r\n                            for embedded into C++ programs and thus provides a very straightforward\r\n                            and transparent way of doing this. Most of the time you understand\r\n                            what’s going on and why. The language syntax looks like a mix of JavaScript and C++.\r\n                        </li>\r\n                    </ul>\r\n                </Paragraph>\r\n\r\n                <Paragraph>\r\n                    If you are reading this article chances are you’re deciding between\r\n                    those three languages, or have already chosen ChaiScript,\r\n                    but can’t find some necessary information in the official\r\n                    documentation. In this (updateable) post I’ll gather a few\r\n                    ChaiScript tips and code snippets that were most difficult\r\n                    for me to discover. They come either from long series of\r\n                    experiments or from the official forum and careful reading\r\n                    of examples and tests. This article assumes that you have\r\n                    already read the documentation, looked through\r\n                    the <Link to=\"https://github.com/ChaiScript/ChaiScript/blob/master/cheatsheet.md\">cheat sheet</Link>, <Link to=\"https://github.com/ChaiScript/ChaiScript/tree/master/samples\">samples</Link> and <Link to=\"https://github.com/ChaiScript/ChaiScript/tree/master/unittests\">unit tests</Link>.\r\n                </Paragraph>\r\n\r\n                <Paragraph>\r\n                    Bootstrapping a project (for impatient):\r\n                </Paragraph>\r\n\r\n                <Code lang=\"c++\">\r\n{`#include <chaiscript.hpp>\r\n#include <chaiscript_stdlib.hpp>\r\n\r\nint main()\r\n{\r\n    chaiscript::ChaiScript engine(chaiscript::Std_Lib::library());\r\n    // ... register API for your scripts\r\n    engine.eval_file(\"script.chai\");\r\n    return 0;\r\n}`}\r\n                </Code>\r\n\r\n                <Paragraph>\r\n                    Attaching C++ function to a script object:\r\n                </Paragraph>\r\n\r\n                <Code lang=\"c++\">\r\n{`// Host program\r\n\r\nvoid logMsg(chaiscript::Boxed_Value& obj, const std::string& s)\r\n{\r\n    std::cout << s << std::endl;\r\n}\r\n\r\n// ...\r\n\r\nengine.add(chaiscript::fun(&logMsg), \"log\");\r\n\r\n// Script\r\n\r\nclass Test\r\n{\r\n    def Test() {}\r\n}\r\n\r\nvar t := create(\"Test\");\r\nt.log(\"abc\");\r\n\r\n// Output\r\n\r\nabc`}\r\n                </Code>\r\n\r\n                <Paragraph>\r\n                    Inheritance, <InlineCode>shared_ptr</InlineCode> to base class, polymorphic function call:\r\n                </Paragraph>\r\n\r\n                <Code lang=\"c++\">\r\n{`// Host program\r\n\r\nstruct Base\r\n{\r\n    virtual ~Base() {} // ChaiScript requires classes to be polymorphic for inheritance to work\r\n};\r\n\r\nstruct A: Base\r\n{\r\n    void func()\r\n    {\r\n        LOG(\"A::func\");\r\n    }\r\n};\r\n\r\nstruct B: Base\r\n{\r\n    void func()\r\n    {\r\n        LOG(\"B::func\");\r\n    }\r\n};\r\n\r\n// Yes, you can pass shared_ptr to your script\r\nstd::shared_ptr<Base> getSmth(const std::string& name)\r\n{\r\n    if (name == \"A\")\r\n        return std::make_shared<A>();\r\n    if (name == \"B\")\r\n        return std::make_shared<B>();\r\n    return nullptr;\r\n}\r\n\r\n// ...\r\n\r\nengine.add(chaiscript::user_type<Base>(), \"Base\");\r\nengine.add(chaiscript::user_type<A>(), \"A\");\r\nengine.add(chaiscript::user_type<B>(), \"B\");\r\nengine.add(chaiscript::base_class<Base, A>());\r\nengine.add(chaiscript::base_class<Base, B>());\r\nengine.add(chaiscript::fun(&A::func), \"func\");\r\nengine.add(chaiscript::fun(&B::func), \"func\");\r\nengine.add(chaiscript::fun(&getSmth), \"getSmth\");\r\n\r\n\r\n// Script\r\n\r\nvar a = getSmth(\"A\");\r\na.func();\r\n\r\nvar b = getSmth(\"B\");\r\nb.func();\r\n\r\n// Output\r\n\r\nA::func\r\nB::func`}\r\n                </Code>\r\n\r\n                <Paragraph>\r\n                    Creating script object from C++, storing it, calling its functions, passing it back to script:\r\n                </Paragraph>\r\n\r\n                <Code lang=\"c++\">\r\n{`// Host program\r\n\r\nchaiscript::Boxed_Value obj;\r\n\r\nchaiscript::Boxed_Value& create(const std::string& className)\r\n{\r\n    obj = engine.eval<chaiscript::Boxed_Value>(className + \"()\");\r\n    return obj;\r\n}\r\n\r\nvoid callFunc()\r\n{\r\n    // Member functions require an implicit first parameter - pointer to the object\r\n    auto func = engine.eval<std::function<void(chaiscript::Boxed_Value&)>>(\"func\");\r\n    func(obj);\r\n}\r\n\r\n//...\r\n\r\nengine.add(chaiscript::fun(&create), \"create\");\r\nengine.add(chaiscript::fun(&callFunc), \"callFunc\");\r\n\r\n\r\n// Script\r\n\r\nclass Test\r\n{\r\n    var id;\r\n\r\n    def Test()\r\n    {\r\n        this.id = 0;\r\n    }\r\n\r\n    def func()\r\n    {\r\n        print(this.id);\r\n    }\r\n}\r\n\r\n// \":=\" here is important. If it were \"=\", ChaiScript would create a deep copy\r\n// and you'll end up having two copies of Test object\r\nvar t := create(\"Test\");\r\nt.id = 100500;\r\nt.func();\r\ncallFunc();\r\n\r\n// Output\r\n\r\n100500\r\n100500`}\r\n                </Code>\r\n\r\n                <Paragraph>\r\n                    Return any object from C++ function to ChaiScript:\r\n                </Paragraph>\r\n\r\n                <Code lang=\"c++\">\r\n{`// Use Boxed_Value as return value\r\nchaiscript::Boxed_Value func(const std::string& token)\r\n{\r\n    if (token == \"Foo\")\r\n        return chaiscript::Boxed_Value(std::make_shared<Test>());\r\n    if (token == \"Bar\")\r\n        return chaiscript::Boxed_Value(std::string(\"Hello, world!\"));\r\n    // .. and so on\r\n    return chaiscript::Boxed_Value(123);\r\n}\r\n\r\n// Register function as normal\r\nscript.add(chaiscript::fun(&func), \"func\");`}\r\n                </Code>\r\n\r\n                <Paragraph>\r\n                    That's it. I hope these recipes saved you some time.\r\n                </Paragraph>\r\n\r\n                <Comments/>\r\n            </div>\r\n        );\r\n    }\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/pages/chaiscript-recipes.js"],"sourceRoot":""}