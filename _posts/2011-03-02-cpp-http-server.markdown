---
layout: page
title:  C++ embedded HTTP server with compression
date:   2011-03-02 00:00:00
---

Иногда бывает нужно внедрить в приложение функциональность простейшего HTTP сервера. Конечно, нет
смысла изобретать свой сервер с нуля, когда есть готовые решения (nginx, apache, etc.). Однако
встраивать базовую поддержку HTTP протокола в своё приложение бывает полезно, например, в тех случаях,
когда нужно обеспечить коммуникацию между сервисами или между сервисом и пользователем. В качестве расширенного
примера можно рассмотреть некий самописный демон, состояние которого для нас критично, и мы хотим его мониторить.
Один из вариантов это реализовать – встроить в демон простой HTTP сервер, который при поступлении запроса будет
генерить страничку со статистикой состояния. После этого мы всегда сможем обратиться по нужному адресу и посмотреть
на интересующие нас цифры. На этой основе потом можно много чего надстроить, например, рисование графиков производительности демона.

<!--break-->

Сначала надо выбрать библиотеку, реализующую функционал HTTP сервера – мы ведь не будем изобретать велосипед?
После нескольких часов в гугле я решил, что стоит попробовать [Mongoose](http://code.google.com/p/mongoose/), потому что а) на неё много где ссылаются, и
б) библиотека оказалась очень простой – 2 файла исходников и нет внешних зависимостей – то, что нужно. К сожалению,
единственный приличный пример использования – исходник веб-чата, включенный в дистрибутив библиотеки (`examples/char.c`),
по нему и пришлось осваивать, остальная документация оказалась какой-то мутной, на мой взгляд.

Прежде чем перейти к реализации, последний момент: сжатие данных. Если сервис рассчитан на отдачу (причём, частую)
больших объёмов данных, в особенности текста, то для сокращения объёмов трафика просто необходимо
сжимать эти данные. Современные браузеры поддерживают ряд алгоритмов сжатия, из которых мы выберем deflate.
Для сжатия данных на клиенте будем использовать библиотеку [zlib](http://zlib.net/).

Итак, время написать простенький сервер, задача которого – отдавать пользователю текст.
Текст может быть каким угодно – мы будем читать его из файла `test.txt`, причём чем больше файл,
тем лучше будет заметно влияние сжатия на объём передаваемого трафика.

Для начала,

* Качаем исходники [Mongoose](http://code.google.com/p/mongoose/), берем файлы `mongoose.c` и `mongoose.h`, кидаем в папку с проектом (здесь и далее пусть папка называется project)
* Качаем исходники [zlib](http://zlib.net/), кидаем в папку `project/zlib/`
* Создаём файл `project/main.cpp`

Я не рассматриваю создание проекта с точки зрения конкретной IDE. Программа будет переносимой, а выбор компилятора уже будет зависеть от платформы.

Содержимое `project/main.cpp` на данный момент пусть выглядит так:

{% highlight cpp %}
#include <cstdlib>
#include <iostream>
#include <fstream>

#include "mongoose.h"
#include "zlib/zlib.h"

/// Пользовательская функция, вызывается сервером при наступлении 
/// очередного события, например, HTTP запроса. Сигнатура должна 
/// быть в точности такой, чтобы соответствовать 
/// типу mg_callback_t (см. mongoose.h)
void * callback(enum mg_event event, struct mg_connection *conn, 
	const struct mg_request_info *request_info)
{
	/// Пока бездействуем. Возврат NULL указывает серверу
	/// использовать дефолтное поведение при обработке 
	/// запроса - отдавать список файлов корневой папки
	return NULL;
}

int main()
{
	/// Опции сервера - корневой каталог и порты, которые
	/// должен слушать сервер (можно указать через запятую, 
	/// например, "9990,9995")
	const char *options[] = 
	{
		"document_root", ".",
		"listening_ports", "9990",
		NULL
	};

	/// Стартуем Mongoose, передавая ему указатель на 
	/// пользовательскую функцию обработки событий 
	/// и массив опций
	mg_context * ctx = mg_start(callback, options);

	/// Тут нужно как-то зациклить программу, чтобы 
	/// сервер продолжал работать. Удобно использовать 
	/// блокирующий вызов, например, std::cin.get()
	std::cout << "Press any key to stop server" << std::endl;
	std::cin.get();

	/// Завершаем работу Mongoose
	mg_stop(ctx);

	return 0;
}
{% endhighlight %}

Пока что наш сервер умеет возвращать только список файлов корневой папки. Перейдём к тому, ради чего всё
затевалось – к генерации текстового ответа с поддержкой сжатия. Для этого дополним функцию callback:

{% highlight cpp %}
void * callback(enum mg_event event, struct mg_connection *conn, 
	const struct mg_request_info *request_info)
{
	/// В качестве источника данных выступает файл,
	/// но в реальной практике тут скорее всего будет
	/// происходить их генерация по определённому
	/// алгоритму. Главное в итоге - получить данные в
	/// "сыром" виде - как массив байтов
	std::ifstream input("test.txt", std::ifstream::binary);

	std::cout << "Reading file..." << std::endl;

	/// Определяем размер файла, чтобы выделить
	/// необходимое количество памяти
	input.seekg(0, std::ios::end);
	unsigned uncompressedLength = input.tellg();
	input.seekg(0, std::ios::beg);

	/// Читаем файл в выделенный буфер
	unsigned char * data = new unsigned char[uncompressedLength];
	input.read((char*)data, uncompressedLength);

	input.close();

	std::cout << "Read " << uncompressedLength << " bytes" << std::endl;

	std::cout << "Compressing..." << std::endl;
	/// zlib рекомендует выделять буфер для сжатых данных 
	/// как минимум такого размера
	unsigned compressedLength = 
		(unsigned int)((uncompressedLength * 1.001f) + 12);
	unsigned char * compressedData = new unsigned char[uncompressedLength];
	/// Сжимаем данные, записывая результат в буфер compressedData.
	/// После выполнения compressedLength будет содержать размер 
	/// сжатых данных
	compress(compressedData, (unsigned long*)&compressedLength, 
		data, uncompressedLength);
	std::cout << "Compressed length: " << compressedLength << std::endl;

	/// Пишем заголовки ответа клиенту.
	/// Важно указать верный MIME (text/plain),
	/// алгоритм сжатия (Content-Encoding: deflate) 
	/// и размер данных (Content-Length)
	mg_printf(conn, 
		"HTTP/1.1 200 OK\r\n"
		"Cache: no-cache\r\n"
		"Content-Type: text/plain\r\n"
		"Content-Encoding: deflate\r\n"
		"Content-Length: %d\r\n"
		"\r\n", compressedLength);

	/// Пишем сами данные
	mg_write(conn, compressedData, compressedLength);
	
	delete [] data;
	delete [] compressedData;

	/// Теперь вместо NULL возвращаем "yes", тем самым
	/// говоря серверу, что мы обработали запрос
	return (void*)"yes";
}
{% endhighlight %}

Теперь собираем проект и пробуем. Библиотеки Mongoose и zlib можно собирать отдельно в статическом или динамическом виде,
а можно включить прямо в проект, как это сделал я. После запуска сервера набираем в браузере `http://localhost:9990/`,
и если всё хорошо, видим содержимое файла `test.txt`. Если в браузере есть инструменты отладки, можно посмотреть,
сколько данных принял браузер, и сравнить с размером исходного файла. Например, в моём эксперименте test.txt
состоял из 6502 одинаковых строчек по 50 символов (я просто копипастил, не заморачиваясь) – в сумме 323.78KB.
В то же время браузер принял всего лишь 1.01KB – экономия при использовании сжатия (особенно однотипных данных) очевидна.